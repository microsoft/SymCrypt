//
//  fdef_asm.symcryptasm   Assembler code for large integer arithmetic in the default data format for the arm64 architecture
//  Expresses asm in a generic enough way to enable generation of MASM and GAS using the
//  symcryptasm_processor.py script and C preprocessor
//
// Copyright (c) Microsoft Corporation. Licensed under the MIT license.
//

#include "symcryptasm_shared.cppasm"

// A digit consists of 4 words of 64 bits each

//UINT32
//SYMCRYPT_CALL
//SymCryptFdefRawAddAsm(
//    _In_reads_bytes_(nDigits * SYMCRYPT_FDEF_DIGIT_SIZE )   PCUINT32    Src1,
//    _In_reads_bytes_(nDigits * SYMCRYPT_FDEF_DIGIT_SIZE )   PCUINT32    Src2,
//    _Out_writes_bytes_(nDigits * SYMCRYPT_FDEF_DIGIT_SIZE ) PUINT32     Dst,
//                                                            UINT32      nDigits )

FUNCTION_START(ARM64EC_NAME_MANGLE(SymCryptFdefRawAddAsm), 4, 8)

    ldp     X_4, X_6, [X_0]         // Load two words of pSrc1
    ldp     X_5, X_7, [X_1]         // Load two words of pSrc2
    adds    X_4, X_4, X_5
    adcs    X_6, X_6, X_7
    stp     X_4, X_6, [X_2]         // Store the result in the destination

    ldp     X_4, X_6, [X_0, #16]    // Load two words of pSrc1
    sub     X_3, X_3, #1            // Decrement the digit count by one
    ldp     X_5, X_7, [X_1, #16]    // Load two words of pSrc2
    adcs    X_4, X_4, X_5
    adcs    X_6, X_6, X_7
    stp     X_4, X_6, [X_2, #16]    // Store the result in the destination

    cbz     X_3, SymCryptFdefRawAddAsmEnd

LABEL(SymCryptFdefRawAddAsmLoop)
    // carry is in the carry flag
    // only update pointers to srcs and destination once per loop to reduce uops and dependencies
    ldp     X_4, X_6, [X_0, #32]!   // Load two words of pSrc1
    ldp     X_5, X_7, [X_1, #32]!   // Load two words of pSrc2
    adcs    X_4, X_4, X_5
    adcs    X_6, X_6, X_7
    stp     X_4, X_6, [X_2, #32]!   // Store the result in the destination

    ldp     X_4, X_6, [X_0, #16]    // Load two words of pSrc1
    sub     X_3, X_3, #1            // Decrement the digit count by one
    ldp     X_5, X_7, [X_1, #16]    // Load two words of pSrc2
    adcs    X_4, X_4, X_5
    adcs    X_6, X_6, X_7
    stp     X_4, X_6, [X_2, #16]    // Store the result in the destination

    cbnz    X_3, SymCryptFdefRawAddAsmLoop

    ALIGN(4)
LABEL(SymCryptFdefRawAddAsmEnd)
    cset    X_0, cs                 // Set the return value equal to the carry

FUNCTION_END(ARM64EC_NAME_MANGLE(SymCryptFdefRawAddAsm))

//UINT32
//SYMCRYPT_CALL
//SymCryptFdefRawSubAsm(
//    _In_reads_bytes_(nDigits * SYMCRYPT_FDEF_DIGIT_SIZE )   PCUINT32    pSrc1,
//    _In_reads_bytes_(nDigits * SYMCRYPT_FDEF_DIGIT_SIZE )   PCUINT32    pSrc2,
//    _Out_writes_bytes_(nDigits * SYMCRYPT_FDEF_DIGIT_SIZE ) PUINT32     pDst,
//                                                            UINT32      nDigits )

FUNCTION_START(ARM64EC_NAME_MANGLE(SymCryptFdefRawSubAsm), 4, 8)

    ldp     X_4, X_6, [X_0]         // Load two words of pSrc1
    ldp     X_5, X_7, [X_1]         // Load two words of pSrc2
    subs    X_4, X_4, X_5
    sbcs    X_6, X_6, X_7
    stp     X_4, X_6, [X_2]         // Store the result in the destination

    ldp     X_4, X_6, [X_0, #16]    // Load two words of pSrc1
    sub     X_3, X_3, #1            // Decrement the digit count by one
    ldp     X_5, X_7, [X_1, #16]    // Load two words of pSrc2
    sbcs    X_4, X_4, X_5
    sbcs    X_6, X_6, X_7
    stp     X_4, X_6, [X_2, #16]    // Store the result in the destination

    cbz     X_3, SymCryptFdefRawSubAsmEnd

LABEL(SymCryptFdefRawSubAsmLoop)
    // borrow is in the carry flag (flipped)
    // only update pointers to srcs and destination once per loop to reduce uops and dependencies
    ldp     X_4, X_6, [X_0, #32]!   // Load two words of pSrc1
    ldp     X_5, X_7, [X_1, #32]!   // Load two words of pSrc2
    sbcs    X_4, X_4, X_5
    sbcs    X_6, X_6, X_7
    stp     X_4, X_6, [X_2, #32]!   // Store the result in the destination

    ldp     X_4, X_6, [X_0, #16]    // Load two words of pSrc1
    sub     X_3, X_3, #1            // Decrement the digit count by one
    ldp     X_5, X_7, [X_1, #16]    // Load two words of pSrc2
    sbcs    X_4, X_4, X_5
    sbcs    X_6, X_6, X_7
    stp     X_4, X_6, [X_2, #16]    // Store the result in the destination

    cbnz    X_3, SymCryptFdefRawSubAsmLoop

    ALIGN(4)
LABEL(SymCryptFdefRawSubAsmEnd)
    cset    X_0, cc                 // If the carry is clear (borrow), set the return value to 1

FUNCTION_END(ARM64EC_NAME_MANGLE(SymCryptFdefRawSubAsm))

//VOID
//SYMCRYPT_CALL
//SymCryptFdefMaskedCopyAsm(
//    _In_reads_bytes_( nDigits*SYMCRYPT_FDEF_DIGIT_SIZE )        PCBYTE      pbSrc,
//    _Inout_updates_bytes_( nDigits*SYMCRYPT_FDEF_DIGIT_SIZE )   PBYTE       pbDst,
//                                                                UINT32      nDigits,
//                                                                UINT32      mask )

FUNCTION_START(ARM64EC_NAME_MANGLE(SymCryptFdefMaskedCopyAsm), 4, 4)

    dup     v0.4s, W_3              // broadcast the mask to v0

LABEL(SymCryptFdefMaskedCopyAsmLoop)
    ldp     q1, q3, [X_0], #32      // Load 4 words of the source
    ldp     q2, q4, [X_1]           // Load 4 words of the destination
    bit     v2.16b, v1.16b, v0.16b  // if the mask is 1s, overwrite the destination with source
    bit     v4.16b, v3.16b, v0.16b  // if the mask is 1s, overwrite the destination with source
    stp     q2, q4, [X_1], #32      // Store the two words in the destination

    sub     X_2, X_2, #1            // Decrement the digit count by one

    cbnz    X_2, SymCryptFdefMaskedCopyAsmLoop

    // Done, no return value

FUNCTION_END(ARM64EC_NAME_MANGLE(SymCryptFdefMaskedCopyAsm))

//VOID
//SYMCRYPT_CALL
//SymCryptFdefRawMulAsm(
//    _In_reads_(nDigits1*SYMCRYPT_FDEF_DIGIT_NUINT32)                PCUINT32    pSrc1,
//                                                                    UINT32      nDigits1,
//    _In_reads_(nDigits2*SYMCRYPT_FDEF_DIGIT_NUINT32)                PCUINT32    pSrc2,
//                                                                    UINT32      nDigits2,
//    _Out_writes_((nDigits1+nDigits2)*SYMCRYPT_FDEF_DIGIT_NUINT32)   PUINT32     pDst )
//
// Basic structure:
//   for each word in Src1:
//       Dst += Src2 * word
//
// Register assignments
//       X_0  = pSrc1 (moving forward one word every outer loop)
//       X_1  = word count of pSrc1
//       X_2  = pSrc2 (moving forward one *digit* every inner loop)
//       X_3  = digit count of pSrc2 and pDst
//       X_4  = pDst (moving forward one *digit* every inner loop)
//       X_5  = Stored pDst (moving forward one word every outer loop)
//       X_6  = Current word loaded from pSrc1
//       X_7, X_8   = Current words loaded in pairs from pSrc2
//       X_9, X_10  = Current words loaded in pairs from pDst
//       X_11, X_12 = Scratch registers for holding the results of multiplies
//       X_13 = Stored pSrc2
//       X_14 = Stored digit count of pSrc2
//       X_15 = Scratch register for holding the results of multiplies

FUNCTION_START(ARM64EC_NAME_MANGLE(SymCryptFdefRawMulAsm), 5, 16)

    lsl     X_1, X_1, #2                // Calculate word count

    sub     X_2, X_2, #32               // offset pSrc2 so we can use pre-increment form of loads
    sub     X_4, X_4, #32               // offset pDst so we can use pre-increment form of loads

    mov     X_5, X_4                    // store pDst
    mov     X_13, X_2                   // store pSrc2
    mov     X_14, X_3                   // store nDigits2 for later

    //
    // First iteration of main loop (no adding of previous values from pDst)
    //
    ands    X_12, X_12, xzr             // Clearing the carry flag and setting X_12 = 0
    ldr     X_6, [X_0]                  // load the first word from pSrc1

LABEL(SymCryptFdefRawMulAsmLoopInner1)
    sub     X_3, X_3, #1                // move one digit up

    ldp     X_7, X_8, [X_2, #32]!       // load 2 words from pSrc2

    mul     X_11, X_6, X_7              // Bits <63:0> of pSrc1[0]*pSrc2[j]
    adcs    X_11, X_11, X_12            // Adding the previous word (if there was a carry from the last addition it is added)
    umulh   X_12, X_6, X_7              // Bits <127:64> of pSrc1[0]*pSrc2[j]

    mul     X_15, X_6, X_8              // Bits <63:0> of pSrc1[0]*pSrc2[j+1]
    adcs    X_15, X_15, X_12            // Adding the previous word (if there was a carry from the last addition it is added)
    umulh   X_12, X_6, X_8              // Bits <127:64> of pSrc1[0]*pSrc2[j+1]

    stp     X_11, X_15, [X_4, #32]!     // Store to destination
    ldp     X_7, X_8, [X_2, #16]        // load 2 words from pSrc2

    mul     X_11, X_6, X_7              // Bits <63:0> of pSrc1[0]*pSrc2[j+2]
    adcs    X_11, X_11, X_12            // Adding the previous word (if there was a carry from the last addition it is added)
    umulh   X_12, X_6, X_7              // Bits <127:64> of pSrc1[0]*pSrc2[j+2]

    mul     X_15, X_6, X_8              // Bits <63:0> of pSrc1[0]*pSrc2[j+3]
    adcs    X_15, X_15, X_12            // Adding the previous word (if there was a carry from the last addition it is added)
    umulh   X_12, X_6, X_8              // Bits <127:64> of pSrc1[0]*pSrc2[j+3]

    stp     X_11, X_15, [X_4, #16]      // Store to destination

    cbnz    X_3, SymCryptFdefRawMulAsmLoopInner1

    adc     X_12, X_12, xzr             // Store the next word into the destination (with the carry if any)
    str     X_12, [X_4, #32]

    sub     X_1, X_1, #1                // move one word up
    add     X_0, X_0, #8                // move start of pSrc1 one word up
    add     X_5, X_5, #8                // move start of pDst one word up

    //
    // MAIN LOOP
    //
LABEL(SymCryptFdefRawMulAsmLoopOuter)
    mov     X_3, X_14                   // set nDigits2
    mov     X_2, X_13                   // set pSrc2
    mov     X_4, X_5                    // set pDst

    ands    X_12, X_12, xzr             // Clearing the carry flag and setting X_12 = 0
    ldr     X_6, [X_0]                  // load the next word from pSrc1

LABEL(SymCryptFdefRawMulAsmLoopInner)
    sub     X_3, X_3, #1                // move one digit up

    ldp     X_7, X_8, [X_2, #32]!       // load 2 words from pSrc2
    ldp     X_9, X_10, [X_4, #32]!      // load 2 words from pDst

    adcs    X_9, X_9, X_12              // Adding the previous word (if there was a carry from the last addition it is added)
    umulh   X_11, X_6, X_7              // Bits <127:64> of pSrc1[i]*pSrc2[j]
    adcs    X_10, X_11, X_10            // Adding the previous word (if there was a carry from the last addition it is added)
    umulh   X_12, X_6, X_8              // Bits <127:64> of pSrc1[i]*pSrc2[j+1]
    adc     X_12, X_12, xzr             // Add the carry if any and don't update the flags

    mul     X_11, X_6, X_7              // Bits <63:0> of pSrc1[i]*pSrc2[j]
    adds    X_9, X_9, X_11              // add the word from the destination and update the flags (this can overflow)
    mul     X_11, X_6, X_8              // Bits <63:0> of pSrc1[i]*pSrc2[j+1]
    adcs    X_10, X_10, X_11            // add the word from the destination and update the flags (this can overflow)

    stp     X_9, X_10, [X_4]            // Store to destination

    ldp     X_7, X_8, [X_2, #16]        // load 2 words from pSrc2
    ldp     X_9, X_10, [X_4, #16]       // load 2 words from pDst

    adcs    X_9, X_9, X_12              // Adding the previous word (if there was a carry from the last addition it is added)
    umulh   X_11, X_6, X_7              // Bits <127:64> of pSrc1[i]*pSrc2[j+2]
    adcs    X_10, X_11, X_10            // Adding the previous word (if there was a carry from the last addition it is added)
    umulh   X_12, X_6, X_8              // Bits <127:64> of pSrc1[i]*pSrc2[j+3]
    adc     X_12, X_12, xzr             // Add the carry if any and don't update the flags

    mul     X_11, X_6, X_7              // Bits <63:0> of pSrc1[i]*pSrc2[j+2]
    adds    X_9, X_9, X_11              // add the word from the destination and update the flags (this can overflow)
    mul     X_11, X_6, X_8              // Bits <63:0> of pSrc1[i]*pSrc2[j+3]
    adcs    X_10, X_10, X_11            // add the word from the destination and update the flags (this can overflow)

    stp     X_9, X_10, [X_4, #16]       // Store to destination

    cbnz    X_3, SymCryptFdefRawMulAsmLoopInner

    adc     X_12, X_12, xzr             // Store the next word into the destination (with the carry if any)
    str     X_12, [X_4, #32]

    subs    X_1, X_1, #1                // move one word up
    add     X_0, X_0, #8                // move start of pSrc1 one word up
    add     X_5, X_5, #8                // move start of pDst one word up

    bne     SymCryptFdefRawMulAsmLoopOuter

    // Done, no return value

FUNCTION_END(ARM64EC_NAME_MANGLE(SymCryptFdefRawMulAsm))

    // Macro for the first loop of the first pass of RawSquareAsm.
    // It takes one word from the source, multiplies it with the mulword,
    // adds the high level word of the previous macro call, and stores it into
    // the destination.
    //
    // No carry flag is propagated from the previous macro call as the maximum is
    // (2^64-1)^2 + 2^64-1 = 2^128 - 2^64
MACRO_START(SQR_SINGLEADD_64, index, src_reg, dst_reg, mul_word, src_carry, dst_carry, scratch0, scratch1)

    ldr     scratch0, [src_reg, #8*index]   // pSrc[i+j]

    mul     scratch1, mul_word, scratch0    // Bits <63:0> of pSrc[i]*pSrc[i+j]
    adds    scratch1, scratch1, src_carry   // Adding the previous word
    umulh   dst_carry, mul_word, scratch0   // Bits <127:64> of pSrc[i]*pSrc[i+j]
    adc     dst_carry, dst_carry, xzr       // Add the intermediate carry and don't update the flags

    str     scratch1, [dst_reg, #8*index]   // Store to destination

MACRO_END()

    // Macro for the remaining loops of the first pass of RawSquareAsm.
    // The only difference to the above is that it also adds the word loaded
    // from the destination buffer.
    //
    // No carry flag is propagated from the previous macro call as the maximum is
    // (2^64-1)^2 + 2(2^64-1) = 2^128 - 1
MACRO_START(SQR_DOUBLEADD_64, index, src_reg, dst_reg, mul_word, src_carry, dst_carry, scratch0, scratch1, scratch2)

    ldr     scratch0, [src_reg, #8*index]   // pSrc[i+j]
    ldr     scratch2, [dst_reg, #8*index]   // pDst[2*(i+j)]

    mul     scratch1, mul_word, scratch0    // Bits <63:0> of pSrc[i]*pSrc[i+j]
    umulh   dst_carry, mul_word, scratch0   // Bits <127:64> of pSrc[i]*pSrc[i+j]

    adds    scratch1, scratch1, scratch2    // Add the word from the destination
    adc     dst_carry, dst_carry, xzr       // Add the intermediate carry and don't update the flags

    adds    scratch1, scratch1, src_carry   // Adding the previous word
    adc     dst_carry, dst_carry, xzr       // Add the intermediate carry and don't update the flags

    str     scratch1, [dst_reg, #8*index]   // Store to destination

MACRO_END()

    // Macro for the third pass loop of RawSquareAsm.
    // It takes one mulword from the source, squares it, and
    // adds it to the even columns of the destination. The carries are propagated
    // to the odd columns.
    //
    // Here we can have a (1-bit) carry to the next call because the maximum value for
    // a pair of columns is (2^64-1)^2+(2^128-1)+1 = 2^129 - 2^65 + 1 < 2^129 - 1
MACRO_START(SQR_DIAGONAL_PROP, index, src_reg, dst_reg, squarelo, squarehi, scratch0, scratch1)

    ldr     squarehi, [src_reg, #8*index]               // mulword
    mul     squarelo, squarehi, squarehi                // Bits <63:0> of m^2
    umulh   squarehi, squarehi, squarehi                // Bits <127:64> of m^2

    ldp     scratch0, scratch1, [dst_reg, #16*index]    // Load

    // Adding the square to the even column
    adcs    squarelo, squarelo, scratch0                // carry from previous and update the flags

    // Propagating the sum to the next column
    adcs    squarehi, squarehi, scratch1                // This can generate a carry

    stp     squarelo, squarehi, [dst_reg, #16*index]    // Store

MACRO_END()

//VOID
//SYMCRYPT_CALL
//SymCryptFdefRawSquareAsm(
//    _In_reads_(nDigits*SYMCRYPT_FDEF_DIGIT_NUINT32)     PCUINT32    pSrc,
//                                                        UINT32      nDigits,
//    _Out_writes_(2*nDigits*SYMCRYPT_FDEF_DIGIT_NUINT32) PUINT32     pDst )
//
// Register assignments
//       X_0  = pSrc
//       X_1  = word count of pSrc
//       X_2  = pSrc (moving forward one digit / 4 words every inner loop)
//       X_3  = digit count of pSrc
//       X_4  = pDst (moving forward one digit every inner loop)
//       X_5  = pDst (moving forward one word every outer loop)
//       X_6  = Current word loaded from pSrc
//       X_7, X_8   = Current words loaded in pairs from pSrc2
//       X_9, X_10  = Current words loaded in pairs from pDst
//       X_11, X_12 = "128-bit" sliding register to hold the result of multiplies
//       X_13 = Stored pSrc
//       X_14 = Digit count of pSrc
//       X_15 = Stored digit count of pSrc
//       X_16 = Stored pDst

FUNCTION_START(ARM64EC_NAME_MANGLE(SymCryptFdefRawSquareAsm), 3, 17)

    mov     X_3, X_1                    // digit count into X_3

    lsl     X_1, X_1, #2                // Calculate word count

    mov     X_4, X_2                    // pDst
    mov     X_5, X_2                    // store pDst
    mov     X_16, X_2                   // store pDst
    mov     X_13, X_0                   // store pSrc
    mov     X_2, X_0                    // inner loop pSrc
    mov     X_14, X_3                   // store nDigits for later
    mov     X_15, X_3                   // store nDigits for later

    //
    // First iteration of main loop (no adding of previous values from pDst)
    //
    mov     X_12, xzr                   // set X_12 = 0
    ldr     X_6, [X_0]                  // load the first word from pSrc1
    str     xzr, [X_4]                  // store 0 for the first word

    b       SymCryptFdefRawSquareAsmInnerLoopInit_Word1

LABEL(SymCryptFdefRawSquareAsmInnerLoopInit_Word0)
    SQR_SINGLEADD_64 0, X_2, X_4, X_6, X_12, X_12, X_7, X_8

LABEL(SymCryptFdefRawSquareAsmInnerLoopInit_Word1)
    SQR_SINGLEADD_64 1, X_2, X_4, X_6, X_12, X_12, X_7, X_8

    SQR_SINGLEADD_64 2, X_2, X_4, X_6, X_12, X_12, X_7, X_8

    SQR_SINGLEADD_64 3, X_2, X_4, X_6, X_12, X_12, X_7, X_8

    sub     X_3, X_3, #1                // move one digit up
    add     X_2, X_2, #32
    add     X_4, X_4, #32

    cbnz    X_3, SymCryptFdefRawSquareAsmInnerLoopInit_Word0

    str     X_12, [X_4]                 // Store the next word into the destination

    sub     X_1, X_1, #2                // move two words up (we started at the word 1)

    mov     X_8, #1                     // Cyclic counter

    //
    // MAIN LOOP
    //
LABEL(SymCryptFdefRawSquareAsmOuterLoop)

    add     X_5, X_5, #8                // move start of pDst one word up

    mov     X_3, X_14                   // set nDigits
    mov     X_2, X_0                    // set pSrc
    mov     X_4, X_5                    // set pDst

    mov     X_11, xzr                   // set X_11 = 0
    mov     X_12, xzr                   // set X_12 = 0
    ldr     X_6, [X_0, X_8, LSL #3]     // load the next word from pSrc

    // Cyclic counter and jump logic
    add     X_8, X_8, #1
    cmp     X_8, #1
    beq     SymCryptFdefRawSquareAsmInnerLoop_Word1
    cmp     X_8, #2
    beq     SymCryptFdefRawSquareAsmInnerLoop_Word2
    cmp     X_8, #3
    beq     SymCryptFdefRawSquareAsmInnerLoop_Word3

    // The following instructions are only executed when X_8 == 4
    mov     X_8, xzr                // Set it to 0

    add     X_0, X_0, #32           // move start of pSrc 4 words up
    add     X_5, X_5, #32           // move pDst 4 words up

    mov     X_2, X_0                // set pSrc
    mov     X_4, X_5                // set pDst

    sub     X_14, X_14, #1          // remove 1 digit
    mov     X_3, X_14               // set the new digit counter

LABEL(SymCryptFdefRawSquareAsmInnerLoop_Word0)
    SQR_DOUBLEADD_64 0, X_2, X_4, X_6, X_12, X_11, X_7, X_9, X_10

LABEL(SymCryptFdefRawSquareAsmInnerLoop_Word1)
    SQR_DOUBLEADD_64 1, X_2, X_4, X_6, X_11, X_12, X_7, X_9, X_10

LABEL(SymCryptFdefRawSquareAsmInnerLoop_Word2)
    SQR_DOUBLEADD_64 2, X_2, X_4, X_6, X_12, X_11, X_7, X_9, X_10

LABEL(SymCryptFdefRawSquareAsmInnerLoop_Word3)
    SQR_DOUBLEADD_64 3, X_2, X_4, X_6, X_11, X_12, X_7, X_9, X_10

    sub     X_3, X_3, #1                // move one digit up
    add     X_2, X_2, #32
    add     X_4, X_4, #32

    cbnz    X_3, SymCryptFdefRawSquareAsmInnerLoop_Word0

    str     X_12, [X_4]                 // Store the next word into the destination

    sub     X_1, X_1, #1                // move one word up
    cbnz    X_1, SymCryptFdefRawSquareAsmOuterLoop

    str     xzr, [X_5, #40]             // Store 0 to destination for the top word

    ////////////////////////////////////////////////////////////////
    // Second Pass - Shifting all results 1 bit left
    ////////////////////////////////////////////////////////////////

    mov     X_3, X_15       // nDigits
    lsl     X_3, X_3, #1    // Double digits
    mov     X_4, X_16       // pDst pointer
    ands    X_7, X_7, xzr   // Clear the flags

LABEL(SymCryptFdefRawSquareAsmSecondPass)

    sub     X_3, X_3, #1    // move one digit up

    ldp     X_7, X_8, [X_4]
    adcs    X_7, X_7, X_7   // Shift left and add the carry
    adcs    X_8, X_8, X_8
    stp     X_7, X_8, [X_4], #16

    ldp     X_9, X_10, [X_4]
    adcs    X_9, X_9, X_9   // Shift left and add the carry
    adcs    X_10, X_10, X_10
    stp     X_9, X_10, [X_4], #16

    cbnz    X_3, SymCryptFdefRawSquareAsmSecondPass

    //////////////////////////////////////////////////////////////////////////////
    // Third Pass - Adding the squares on the even columns and propagating the sum
    //////////////////////////////////////////////////////////////////////////////

    ands    X_7, X_7, xzr   // Clear the flags
    mov     X_0, X_13       // src pointer
    mov     X_4, X_16       // pDst pointer
    mov     X_3, X_15       // nDigits

LABEL(SymCryptFdefRawSquareAsmThirdPass)
    SQR_DIAGONAL_PROP 0, X_0, X_4, X_6, X_7, X_8, X_9
    SQR_DIAGONAL_PROP 1, X_0, X_4, X_6, X_7, X_8, X_9
    SQR_DIAGONAL_PROP 2, X_0, X_4, X_6, X_7, X_8, X_9
    SQR_DIAGONAL_PROP 3, X_0, X_4, X_6, X_7, X_8, X_9

    sub     X_3, X_3, #1        // move one digit up
    add     X_0, X_0, #32       // One digit up (not updated in SQR_DIAGONAL_PROP)
    add     X_4, X_4, #64       // Two digits up (not updated in SQR_DIAGONAL_PROP)

    cbnz    X_3, SymCryptFdefRawSquareAsmThirdPass

    // Done, no return value

FUNCTION_END(ARM64EC_NAME_MANGLE(SymCryptFdefRawSquareAsm))

//VOID
//SYMCRYPT_CALL
//SymCryptFdefModAdd256Asm(
//    _In_                            PCSYMCRYPT_MODULUS      pmMod,
//    _In_                            PCSYMCRYPT_MODELEMENT   peSrc1,
//    _In_                            PCSYMCRYPT_MODELEMENT   peSrc2,
//    _Out_                           PSYMCRYPT_MODELEMENT    peDst )

FUNCTION_START(ARM64EC_NAME_MANGLE(SymCryptFdefModAdd256Asm), 4, 10)

    add     X_0, X_0, #SymCryptModulusValueOffsetArm64 // pMod

    // compute Src1 + Src2 into (X_4, X_5, X_6, X_7)
    ldp     X_4, X_5, [X_1]       // Load two words of peSrc1
    ldp     X_8, X_9, [X_2]       // Load two words of peSrc2
    adds    X_4, X_4, X_8
    adcs    X_5, X_5, X_9

    ldp     X_6, X_7, [X_1, #16]  // Load two words of peSrc1
    ldp     X_8, X_9, [X_2, #16]  // Load two words of peSrc2
    adcs    X_6, X_6, X_8
    adcs    X_7, X_7, X_9

    cset    X_1, cs                 // If the carry is set, set X_1 to 1 (else 0)

    // Compute sum - Mod into (X_2, X_8, X_9, X_0) = sum - modulus

    ldp     X_2, X_8, [X_0]       // Load two words of pMod
    subs    X_2, X_4, X_2
    sbcs    X_8, X_5, X_8

    ldp     X_9, X_0, [X_0, #16]  // Load two words of pMod
    sbcs    X_9, X_6, X_9
    sbcs    X_0, X_7, X_0

    // Choose between the two
    // addition carry = 1, then subtraction borrow = 1 and we pick the 2nd result.
    // addition carry = 0 and subtraction borrow = 0: pick 2nd result
    // addition carry = 0 and subtraction borrow = 1: pick first result

    // We set borrow condition (cc) when subtracting with carry from X_1
    // iff addition carry 0 and subtraction borrow 1
    sbcs    X_1, X_1, XZR

    csel    X_4, X_4, X_2, cc
    csel    X_5, X_5, X_8, cc
    stp     X_4, X_5, [X_3]

    csel    X_6, X_6, X_9, cc
    csel    X_7, X_7, X_0, cc
    stp     X_6, X_7, [X_3, #16]

FUNCTION_END(ARM64EC_NAME_MANGLE(SymCryptFdefModAdd256Asm))

//VOID
//SYMCRYPT_CALL
//SymCryptFdefModSub256Asm(
//    _In_                            PCSYMCRYPT_MODULUS      pmMod,
//    _In_                            PCSYMCRYPT_MODELEMENT   peSrc1,
//    _In_                            PCSYMCRYPT_MODELEMENT   peSrc2,
//    _Out_                           PSYMCRYPT_MODELEMENT    peDst )

FUNCTION_START(ARM64EC_NAME_MANGLE(SymCryptFdefModSub256Asm), 4, 10)

    add     X_0, X_0, #SymCryptModulusValueOffsetArm64 // pMod

    // compute Src1 - Src2 into (X_4, X_5, X_6, X_7)
    ldp     X_4, X_5, [X_1]         // Load two words of peSrc1
    ldp     X_8, X_9, [X_2]         // Load two words of peSrc2
    subs    X_4, X_4, X_8
    sbcs    X_5, X_5, X_9

    ldp     X_6, X_7, [X_1, #16]    // Load two words of peSrc1
    ldp     X_8, X_9, [X_2, #16]    // Load two words of peSrc2
    sbcs    X_6, X_6, X_8
    sbcs    X_7, X_7, X_9

    // Load the masked modulus into (X_1, X_2, X_8, X_9)
    ldp     X_1, X_2, [X_0]         // Load two words of pMod
    csel    X_1, X_1, XZR, cc       // If we did not borrow, zero the modulus
    csel    X_2, X_2, XZR, cc

    ldp     X_8, X_9, [X_0, #16]    // Load two words of pMod
    csel    X_8, X_8, XZR, cc
    csel    X_9, X_9, XZR, cc

    // Add the masked modulus
    adds    X_4, X_4, X_1
    adcs    X_5, X_5, X_2
    stp     X_4, X_5, [X_3]

    adcs    X_6, X_6, X_8
    adc     X_7, X_7, X_9
    stp     X_6, X_7, [X_3, #16]

FUNCTION_END(ARM64EC_NAME_MANGLE(SymCryptFdefModSub256Asm))


MACRO_START(MUL_AND_MONTGOMERY_REDUCE14_INTERLEAVE, T0, T1, Ai, pB, pM, K, Inv64, R0, R1, R2, R3, R4, R5)
    // (R1, R2, R3, R4, R5) = Ai * (B0..3) + (R1, R2, R3, R4, R5)
    // (xx, R1, R2, R3, R4, R5, R0) = K * (M0..3) + (R0, R1, R2, R3, R4, R5)
    // K = Inv64 * R1
    // Note K is chosen using pMod's montgomery inverse s.t. xx would get set to 0
    // pM is a pointer the bytes of the modulus (i.e. offset into SYMCRYPT_MODULUS structure)
    // R5 is 0 or 1 at start
    // R0 is 0 or 1 at end
    // T0, T1 = scratch
    // Ai is also used as scratch when it's no longer needed

    // (R1, R2, R3, R4, R5) += Ai * B even
    ldr     T0, [pB]
    mul     T1, Ai, T0
    adds    R1, R1, T1
    umulh   T0, Ai, T0
    adcs    R2, R2, T0

    ldr     T0, [pB, #16]
    mul     T1, Ai, T0
    adcs    R3, R3, T1
    umulh   T0, Ai, T0
    adcs    R4, R4, T0

    adc     R5, R5, XZR // R5 in range [0,2]

    // (R2, R3, R4, R5) += Ai * B odd
    ldr     T0, [pB, #8]
    mul     T1, Ai, T0
    adds    R2, R2, T1
    umulh   T0, Ai, T0
    adcs    R3, R3, T0

    ldr     T0, [pB, #24]
    mul     T1, Ai, T0
    adcs    R4, R4, T1
    umulh   Ai, Ai, T0
    adc     Ai, Ai, XZR // Ai in range [0, 2^64-1]
                        // defer adding Ai to R5 to avoid overflowing earlier than necessary

    // (xx, R1, R2, R3, R4, R5) = K * M even + (R0, R1, R2, R3, R4, R5)
    ldr     T0, [pM]
    mul     T1,  K, T0
    adds    R0, R0, T1  // Sets R0 to 0
    umulh   T0,  K, T0
    adcs    R1, R1, T0

    ldr     T0, [pM, #16]
    mul     T1,  K, T0
    adcs    R2, R2, T1
    umulh   T0,  K, T0
    adcs    R3, R3, T0

    adcs    R4, R4, XZR
    adc     R5, R5, XZR // R5 in range [0,3]

    // (R1, R2, R3, R4, R5, R0) = K * M odd + (R1, R2, R3, R4, R5, R0)
    ldr     T0, [pM, #8]
    mul     T1,  K, T0
    adds    R1, R1, T1
    umulh   T0,  K, T0
    adcs    R2, R2, T0

    ldr     T0, [pM, #24]
    mul     T1,  K, T0
    adcs    R3, R3, T1
    umulh   T0,  K, T0
    adcs    R4, R4, T0

    mul     K, R1, Inv64
    adcs    R5, R5, Ai
    cset    R0, cs
MACRO_END()

//VOID
//SYMCRYPT_CALL
//SymCryptFdefModMulMontgomery256Asm(
//    _In_                            PCSYMCRYPT_MODULUS      pMod,
//    _In_                            PCSYMCRYPT_MODELEMENT   pSrc1,
//    _In_                            PCSYMCRYPT_MODELEMENT   pSrc2,
//    _Out_                           PSYMCRYPT_MODELEMENT    pDst );

FUNCTION_START(ARM64EC_NAME_MANGLE(SymCryptFdefModMulMontgomery256Asm), 4, 15)

    // X_0 = pMod
    // X_1 = pSrc1
    // X_2 = pSrc2
    // X_3 = pDst
    // X_4 = Ai
    // X_5, X_6 = T0, T1
    // X_7 = Inv64
    // X_8 = K
    // X_9, X_10, X_11, X_12, X_13, X_14 = R0..R5

ALTERNATE_ENTRY(ARM64EC_NAME_MANGLE(SymCryptFdefModMulMontgomery256AsmInternal))

    ldr     X_4, [X_1]              // Load pSrc1

    ldp     X_10, X_11, [X_2]       // Load pSrc2 B[0], B[1]
    mul      X_9,  X_4, X_10        // R0 = <63:0>   of A[0]*B[0]
    umulh   X_10,  X_4, X_10        // R1 = <127:64> of A[0]*B[0]

    mul      X_5,  X_4, X_11        // T0 = <63:0>   of A[0]*B[1]
    adds    X_10, X_10,  X_5        // Adding the previous word
    umulh   X_11,  X_4, X_11        // R2 = <127:64> of A[0]*B[1]

    ldp     X_12, X_13, [X_2, #16]  // Load pSrc2 B[2], B[3]
    mul      X_5,  X_4, X_12        // T0 = <63:0>   of A[0]*B[2]
    adcs    X_11, X_11,  X_5        // Adding the previous word (if there was a carry from the last addition it is added)
    umulh   X_12,  X_4, X_12        // R3 = <127:64> of A[0]*B[2]

    mul      X_5,  X_4, X_13        // T0 = <63:0>   of A[0]*B[3]
    adcs    X_12, X_12,  X_5        // Adding the previous word (if there was a carry from the last addition it is added)
    umulh   X_13,  X_4, X_13        // R4 = <127:64> of A[0]*B[3]
    adc     X_13, X_13,  XZR

    eor     X_14, X_14, X_14

    ldr     X_7, [X_0, #SymCryptModulusInv64OffsetArm64]
    mul     X_8, X_9, X_7           // K = R0 * Inv64

    add     X_0, X_0, #SymCryptModulusValueOffsetArm64

    ldr     X_4, [X_1, #8]
    MUL_AND_MONTGOMERY_REDUCE14_INTERLEAVE X_5, X_6, X_4, X_2, X_0, X_8, X_7, X_9, X_10, X_11, X_12, X_13, X_14

    ldr     X_4, [X_1, #16]
    MUL_AND_MONTGOMERY_REDUCE14_INTERLEAVE X_5, X_6, X_4, X_2, X_0, X_8, X_7, X_10, X_11, X_12, X_13, X_14, X_9

    ldr     X_4, [X_1, #24]
    MUL_AND_MONTGOMERY_REDUCE14_INTERLEAVE X_5, X_6, X_4, X_2, X_0, X_8, X_7, X_11, X_12, X_13, X_14, X_9, X_10

    // (xx, R1, R2, R3, R4, R5) = K * M even + (R0, R1, R2, R3, R4, R5)

    ldp      X_4,  X_5, [X_0]   // Load Mod
    mul      X_1,  X_8, X_4
    adds    X_12, X_12, X_1     // Sets R0 to 0
    umulh    X_2,  X_8, X_4
    adcs    X_13, X_13, X_2

    ldp      X_6,  X_7, [X_0, #16]
    mul      X_1,  X_8, X_6
    adcs    X_14, X_14, X_1
    umulh    X_2,  X_8, X_6
    adcs     X_9,  X_9, X_2

    adcs    X_10, X_10, XZR
    adc     X_11, X_11, XZR

    // (R1, R2, R3, R4, R5) = K * M odd + (R1, R2, R3, R4, R5)
    mul      X_1,  X_8, X_5
    adds    X_13, X_13, X_1
    umulh    X_2,  X_8, X_5
    adcs    X_14, X_14, X_2

    mul      X_1,  X_8, X_7
    adcs     X_9,  X_9, X_1
    umulh    X_2,  X_8, X_7
    adcs    X_10, X_10, X_2

    adc     X_11, X_11, XZR

    // Montgomery-reduced multiplication value in (X_13, X_14, X_9, X_10, X_11), and it is less than 2*Modulus
    // Compute value - Mod into (X_4, X_5, X_6, X_7), Cy = inverted subtraction borrow

    subs    X_4, X_13, X_4
    sbcs    X_5, X_14, X_5
    sbcs    X_6,  X_9, X_6
    sbcs    X_7, X_10, X_7

    // Choose between the two
    // addition carry = 1, then subtraction borrow = 1 and we pick the 2nd result.
    // addition carry = 0 and subtraction borrow = 0: pick 2nd result
    // addition carry = 0 and subtraction borrow = 1: pick first result

    // We set borrow condition (cc) when subtracting with carry from X_11
    // iff addition carry 0 and subtraction borrow 1
    sbcs    X_11, X_11, XZR

    csel    X_13, X_13, X_4, cc
    csel    X_14, X_14, X_5, cc
    stp     X_13, X_14, [X_3]

    csel     X_9,  X_9, X_6, cc
    csel    X_10, X_10, X_7, cc
    stp      X_9, X_10, [X_3, #16]

FUNCTION_END(ARM64EC_NAME_MANGLE(SymCryptFdefModMulMontgomery256Asm))

//VOID
//SYMCRYPT_CALL
//SymCryptFdefModSquareMontgomery256Asm(
//    _In_                            PCSYMCRYPT_MODULUS      pMod,
//    _In_                            PCSYMCRYPT_MODELEMENT   pSrc,
//    _Out_                           PSYMCRYPT_MODELEMENT    pDst );

// Note we specify 4 arguments to keep prolog of this and SymCryptFdefModMulMontgomery256Asm the same
FUNCTION_START(ARM64EC_NAME_MANGLE(SymCryptFdefModSquareMontgomery256Asm), 4, 15)

    // X_0 = pMod
    // X_1 = pSrc
    // X_2 = pDst

    mov     X_3, X_2
    mov     X_2, X_1

    // Just jump into multiply, similar to SymCryptWipeAsm jumping into memset.

    b       ARM64EC_NAME_MANGLE(SymCryptFdefModMulMontgomery256AsmInternal)

FUNCTION_END(ARM64EC_NAME_MANGLE(SymCryptFdefModSquareMontgomery256Asm))

//VOID
//SYMCRYPT_CALL
//SymCryptFdefModAdd384Asm(
//    _In_                            PCSYMCRYPT_MODULUS      pmMod,
//    _In_                            PCSYMCRYPT_MODELEMENT   peSrc1,
//    _In_                            PCSYMCRYPT_MODELEMENT   peSrc2,
//    _Out_                           PSYMCRYPT_MODELEMENT    peDst )

FUNCTION_START(ARM64EC_NAME_MANGLE(SymCryptFdefModAdd384Asm), 4, 14)

    add     X_0, X_0, #SymCryptModulusValueOffsetArm64 // pMod

    // compute Src1 + Src2 into (X_4, X_5, X_6, X_7, X_8, X_9)
    ldp     X_4,  X_5,  [X_1]       // Load two words of peSrc1
    ldp     X_10, X_11, [X_2]       // Load two words of peSrc2
    adds    X_4,  X_4,  X_10
    adcs    X_5,  X_5,  X_11

    ldp     X_6,  X_7,  [X_1, #16]  // Load two words of peSrc1
    ldp     X_10, X_11, [X_2, #16]  // Load two words of peSrc2
    adcs    X_6,  X_6,  X_10
    adcs    X_7,  X_7,  X_11

    ldp     X_8,  X_9,  [X_1, #32]  // Load two words of peSrc1
    ldp     X_10, X_11, [X_2, #32]  // Load two words of peSrc2
    adcs    X_8,  X_8,  X_10
    adcs    X_9,  X_9,  X_11

    cset    X_1, cs                 // If the carry is set, set X_1 to 1 (else 0)

    // Compute sum - Mod into (X_2, X_10, X_11, X_12, X_13, X_0) = sum - modulus

    ldp     X_2, X_10,  [X_0]       // Load two words of pMod
    subs    X_2,  X_4,  X_2
    sbcs    X_10, X_5,  X_10

    ldp     X_11, X_12, [X_0, #16]  // Load two words of pMod
    sbcs    X_11, X_6,  X_11
    sbcs    X_12, X_7,  X_12

    ldp     X_13, X_0,  [X_0, #32]  // Load two words of pMod
    sbcs    X_13, X_8,  X_13
    sbcs    X_0,  X_9,  X_0

    // Choose between the two
    // addition carry = 1, then subtraction borrow = 1 and we pick the 2nd result.
    // addition carry = 0 and subtraction borrow = 0: pick 2nd result
    // addition carry = 0 and subtraction borrow = 1: pick first result

    // We set borrow condition (cc) when subtracting with carry from X_1
    // iff addition carry 0 and subtraction borrow 1
    sbcs    X_1, X_1, XZR

    csel    X_4, X_4, X_2,  cc
    csel    X_5, X_5, X_10, cc
    stp     X_4, X_5, [X_3]

    csel    X_6, X_6, X_11, cc
    csel    X_7, X_7, X_12, cc
    stp     X_6, X_7, [X_3, #16]

    csel    X_8, X_8, X_13, cc
    csel    X_9, X_9, X_0,  cc
    stp     X_8, X_9, [X_3, #32]

FUNCTION_END(ARM64EC_NAME_MANGLE(SymCryptFdefModAdd384Asm))

//VOID
//SYMCRYPT_CALL
//SymCryptFdefModSub384Asm(
//    _In_                            PCSYMCRYPT_MODULUS      pmMod,
//    _In_                            PCSYMCRYPT_MODELEMENT   peSrc1,
//    _In_                            PCSYMCRYPT_MODELEMENT   peSrc2,
//    _Out_                           PSYMCRYPT_MODELEMENT    peDst )

FUNCTION_START(ARM64EC_NAME_MANGLE(SymCryptFdefModSub384Asm), 4, 13)

    add     X_0, X_0, #SymCryptModulusValueOffsetArm64 // pMod

    // compute Src1 - Src2 into (X_4, X_5, X_6, X_7, X_8, X_9)
    ldp     X_4,  X_5,  [X_1]         // Load two words of peSrc1
    ldp     X_10, X_11, [X_2]         // Load two words of peSrc2
    subs    X_4,  X_4,  X_10
    sbcs    X_5,  X_5,  X_11

    ldp     X_6,  X_7,  [X_1, #16]    // Load two words of peSrc1
    ldp     X_10, X_11, [X_2, #16]    // Load two words of peSrc2
    sbcs    X_6,  X_6,  X_10
    sbcs    X_7,  X_7,  X_11

    ldp     X_8,  X_9,  [X_1, #32]    // Load two words of peSrc1
    ldp     X_10, X_11, [X_2, #32]    // Load two words of peSrc2
    sbcs    X_8,  X_8,  X_10
    sbcs    X_9,  X_9,  X_11

    // Load the masked modulus into (X_1, X_2, X_10, X_11, X_12, X_0)
    ldp     X_1, X_2, [X_0]         // Load two words of pMod
    csel    X_1, X_1, XZR, cc       // If we did not borrow, zero the modulus
    csel    X_2, X_2, XZR, cc

    ldp     X_10, X_11, [X_0, #16]  // Load two words of pMod
    csel    X_10, X_10, XZR, cc
    csel    X_11, X_11, XZR, cc

    ldp     X_12, X_0,  [X_0, #32]  // Load two words of pMod
    csel    X_12, X_12, XZR, cc
    csel    X_0,  X_0,  XZR, cc

    // Add the masked modulus
    adds    X_4, X_4, X_1
    adcs    X_5, X_5, X_2
    stp     X_4, X_5, [X_3]

    adcs    X_6, X_6, X_10
    adcs    X_7, X_7, X_11
    stp     X_6, X_7, [X_3, #16]

    adcs    X_8, X_8, X_12
    adc     X_9, X_9, X_0
    stp     X_8, X_9, [X_3, #32]

FUNCTION_END(ARM64EC_NAME_MANGLE(SymCryptFdefModSub384Asm))


MACRO_START(MUL_AND_MONTGOMERY_REDUCE16_P384_INTERLEAVE, T0, T1, Ai, pB, K, N3, R0, R1, R2, R3, R4, R5, R6, R7)
    // (R1, R2, R3, R4, R5, R6, R7) = Ai * (B0..5) + (R1, R2, R3, R4, R5, R6, R7)
    // (xx, R1, R2, R3, R4, R5, R6, R7, R0) = K * (M0..5) + (R0, R1, R2, R3, R4, R5, R6, R7)
    // Note K is chosen using pMod's montgomery inverse s.t. xx would get set to 0
    // R7 is 0 or 1 at start
    // R0 is 0 or 1 at end
    // N3 in [0, 2] at start and end
    // T0, T1 = scratch
    // Ai is also used as scratch when it's no longer needed

    // (R1, R2, R3, R4, R5, R6, R7) += Ai * B even
    ldr     T0, [pB]
    mul     T1, Ai, T0
    adds    R1, R1, T1
    umulh   T0, Ai, T0
    adcs    R2, R2, T0

    ldr     T0, [pB, #16]
    mul     T1, Ai, T0
    adcs    R3, R3, T1
    umulh   T0, Ai, T0
    adcs    R4, R4, T0

    ldr     T0, [pB, #32]
    mul     T1, Ai, T0
    adcs    R5, R5, T1
    umulh   T0, Ai, T0
    adcs    R6, R6, T0

    adc     R7, R7, XZR // R7 in range [0,2]

    // (R2, R3, R4, R5, R6, R7) += Ai * B odd
    ldr     T0, [pB, #8]
    mul     T1, Ai, T0
    adds    R2, R2, T1
    umulh   T0, Ai, T0
    adcs    R3, R3, T0

    ldr     T0, [pB, #24]
    mul     T1, Ai, T0
    adcs    R4, R4, T1
    umulh   T0, Ai, T0
    adcs    R5, R5, T0

    ldr     T0, [pB, #40]
    mul     T1, Ai, T0
    adcs    R6, R6, T1
    umulh   Ai, Ai, T0
    adc     Ai, Ai, XZR // Ai in range [0, 2^64-1]
                        // defer adding Ai to R7 to avoid overflowing earlier than necessary

    // P384 has a modulus with a form which makes it possible to perform Montgomery reduction
    // in an interesting way. The modulus is:
    // 2^384 - 2^128 - 2^96 + 2^32 - 1
    // This means when we want to add a multiple of the Modulus in reduction, we can actually
    // avoid multiplication instructions entirely.
    // On Arm64, multiplication instruction throughput is often the bottleneck, and there is no
    // distinction in cost between addition and subtraction (unlike on AMD64).
    // So we do the reduction directly using shifts, adds, and subtracts.
    // On entry to this macro we have N3 representing a deferred subtraction (in range [0,2]) from the
    // 3rd word of the last macro (now aligned to the 2nd word of this macro), on exit we set N3 to be
    // the subtraction to defer to the next round.
    //
    //            ____ ____ ____ ____ ____ ____
    //           | M5 | M4 | M3 | M2 | M1 | M0 |
    //           | ff | ff | ff | fe | f0 | 0f | (P384 modulus if you sign extend each nibble to 32b)
    //           |____|____|____|____|____|____|
    //  ____ ____ ____ ____ ____ ____ ____ ____
    // |    |    |\  /|\  /|\  /|    |    |    |
    // | R7 | R6 | R5 | R4 | R3 | R2 | R1 | R0 |   R0h = R0 >> 32
    // |____|____|/__\|/__\|/__\|____|____|____|   R0l = R0 mod 2^32
    //                                      | x Inv64 (0x0000000100000001)
    //                                     _v__
    //                      ____          |    |
    //                     |    |         |  K | K = (R0 + (R0 << 32)) mod 2^64
    //                     | N3 |         |____|   = ((R0h +32 R0l) << 32) + R0l
    //       ____          |____|____                      ^^^ by +32 we mean addition modulo 2^32
    //      |    |              |    |
    //    + |  K |            - |  K |
    //      |____|              |____|____
    //                          |  K |  K |
    //                        - |>>32|<<32|   K << 32 mod 2^64 = R0l << 32
    //                          |____|____|   K >> 32 mod 2^64 = R0h +32 R0l
    //                               |    |
    //                             + |  J |   J = (K*M0 + R0) >> 64
    //                           ____|____|
    //                          |    |
    //                        - |N3in|
    //                          |____|
    //
    // The logic for how we compute J is a little involved:
    // (K * M0) + R0 = (((R0h +32 R0l) << 32) + R0l) * (1<<32 - 1)                        + R0
    //               = (((R0h +32 R0l) << 64) + R0l<<32) - (((R0h +32 R0l) << 32) + R0l)  + R0h<<32 + R0l
    //               =  ((R0h +32 R0l) << 64) + R0l<<32  -  ((R0h +32 R0l) << 32)         + R0h<<32
    //               =  ((R0h +32 R0l) << 64) + (((R0h + R0l) - (R0h +32 R0l)) << 32)
    //                                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^ this is exactly bit 33 of R0h+R0l
    //               =  ((R0h +32 R0l) + ((R0h +33 R0l)>>32)) << 64
    // => J = (R0h +32 R0l) + ((R0h +33 R0l)>>32)

    lsl     T0, R0, #32     // T0 = R0<<32 = K<<32
    adds     K, R0, T0      //  K = R0 + T0 = R0 + (R0<<32) = R0 * Inv64
    lsr     T1, K, #32      // T1 = K>>32
    adcs    R1, R1, T1      // R1 = R1 + J = R1 + T1 + carry from setting K
    add     T1, T1, N3      // T1 += N3in; cannot overflow as T1 < 2^32
    adcs    R2, R2, XZR
    csetm   N3, cs          // N3 -1 if carry, else 0

    subs    R1, R1, T0      // subtract [ K>>32 + N3in || K<<32 ]
    sbcs    R2, R2, T1
    cinc    N3, N3, cc      // N3 += 1 iff borrow; N3 in [0, 1] as carry in addition => borrow here

    subs    R2, R2, K       // subtract K
    cinc    N3, N3, cc      // N3 += 1 iff borrow; N3 in [0, 2]

    adds    R6, R6, K       // add K
    adcs    R7, R7, Ai
    cset    R0, cs
MACRO_END()

//VOID
//SYMCRYPT_CALL
//SymCryptFdefModMulMontgomeryP384Asm(
//    _In_                            PCSYMCRYPT_MODULUS      pMod,
//    _In_                            PCSYMCRYPT_MODELEMENT   pSrc1,
//    _In_                            PCSYMCRYPT_MODELEMENT   pSrc2,
//    _Out_                           PSYMCRYPT_MODELEMENT    pDst );

FUNCTION_START(ARM64EC_NAME_MANGLE(SymCryptFdefModMulMontgomeryP384Asm), 4, 17)

    // X_0 = pMod
    // X_1 = pSrc1
    // X_2 = pSrc2
    // X_3 = pDst
    // X_4 = Ai
    // X_5, X_6, X_7 = T0, T1, N3
    // X_8 = K
    // X_9, X_10, X_11, X_12, X_13, X_14, X_15, X_16 = R0..R7

ALTERNATE_ENTRY(ARM64EC_NAME_MANGLE(SymCryptFdefModMulMontgomeryP384AsmInternal))

    ldr     X_4, [X_1]              // Load pSrc1

    ldp     X_10, X_11, [X_2]       // Load pSrc2 B[0], B[1]
    mul      X_9,  X_4, X_10        // R0 = <63:0>   of A[0]*B[0]
    umulh   X_10,  X_4, X_10        // R1 = <127:64> of A[0]*B[0]

    mul      X_5,  X_4, X_11        // T0 = <63:0>   of A[0]*B[1]
    adds    X_10, X_10,  X_5        // Adding the previous word
    umulh   X_11,  X_4, X_11        // R2 = <127:64> of A[0]*B[1]

    ldp     X_12, X_13, [X_2, #16]  // Load pSrc2 B[2], B[3]
    mul      X_5,  X_4, X_12        // T0 = <63:0>   of A[0]*B[2]
    adcs    X_11, X_11,  X_5        // Adding the previous word (if there was a carry from the last addition it is added)
    umulh   X_12,  X_4, X_12        // R3 = <127:64> of A[0]*B[2]

    mul      X_5,  X_4, X_13        // T0 = <63:0>   of A[0]*B[3]
    adcs    X_12, X_12,  X_5        // Adding the previous word (if there was a carry from the last addition it is added)
    umulh   X_13,  X_4, X_13        // R4 = <127:64> of A[0]*B[3]

    ldp     X_14, X_15, [X_2, #32]  // Load pSrc2 B[4], B[5]
    mul      X_5,  X_4, X_14        // T0 = <63:0>   of A[0]*B[4]
    adcs    X_13, X_13,  X_5        // Adding the previous word (if there was a carry from the last addition it is added)
    umulh   X_14,  X_4, X_14        // R3 = <127:64> of A[0]*B[4]

    mul      X_5,  X_4, X_15        // T0 = <63:0>   of A[0]*B[5]
    adcs    X_14, X_14,  X_5        // Adding the previous word (if there was a carry from the last addition it is added)
    umulh   X_15,  X_4, X_15        // R4 = <127:64> of A[0]*B[5]
    adc     X_15, X_15,  XZR

    eor     X_16, X_16, X_16
    eor     X_7, X_7, X_7

    ldr     X_4, [X_1, #8]
    MUL_AND_MONTGOMERY_REDUCE16_P384_INTERLEAVE X_5, X_6, X_4, X_2, X_8, X_7, X_9, X_10, X_11, X_12, X_13, X_14, X_15, X_16

    ldr     X_4, [X_1, #16]
    MUL_AND_MONTGOMERY_REDUCE16_P384_INTERLEAVE X_5, X_6, X_4, X_2, X_8, X_7, X_10, X_11, X_12, X_13, X_14, X_15, X_16, X_9

    ldr     X_4, [X_1, #24]
    MUL_AND_MONTGOMERY_REDUCE16_P384_INTERLEAVE X_5, X_6, X_4, X_2, X_8, X_7, X_11, X_12, X_13, X_14, X_15, X_16, X_9, X_10

    ldr     X_4, [X_1, #32]
    MUL_AND_MONTGOMERY_REDUCE16_P384_INTERLEAVE X_5, X_6, X_4, X_2, X_8, X_7, X_12, X_13, X_14, X_15, X_16, X_9, X_10, X_11

    ldr     X_4, [X_1, #40]
    MUL_AND_MONTGOMERY_REDUCE16_P384_INTERLEAVE X_5, X_6, X_4, X_2, X_8, X_7, X_13, X_14, X_15, X_16, X_9, X_10, X_11, X_12

    // see MUL_AND_MONTGOMERY_REDUCE16_P384_INTERLEAVE for how this reduction works
    lsl     X_5, X_14, #32  // T0 = R0<<32 = K<<32
    adds    X_8, X_14, X_5  //  K = R0 + T0 = R0 + (R0<<32)
    lsr     X_6, X_8, #32   // T1 = K>>32
    adcs    X_15, X_15, X_6 // R1 = R1 + J = R1 + T1 + carry from setting K
    add     X_6, X_6, X_7   // T1 += N3in; cannot overflow as T1 < 2^32
    adcs    X_16, X_16, XZR
    csetm   X_7, cs         // N3 -1 if carry, else 0

    subs    X_15, X_15, X_5 // subtract K<<32
    sbcs    X_16, X_16, X_6
    cinc    X_7, X_7, cc    // N3 += 1 iff borrow; N3 in [0, 1] as carry in addition => borrow here

    subs    X_16, X_16, X_8 // subtract K
    sbcs    X_9, X_9, X_7   // subtract N3 and borrow if any
    sbcs    X_10, X_10, XZR
    sbcs    X_11, X_11, XZR
    sbcs    X_12, X_12, XZR
    sbc     X_13, X_13, XZR

    adds    X_12, X_12, X_8 // add K
    adc     X_13, X_13, XZR

    // Montgomery-reduced multiplication value in (X_15, X_16, X_9, X_10, X_11, X_12, X_13), and it is less than 2*Modulus
    // Compute value - Mod into (X_4, X_5, X_6, X_7, X_14, X_0), Cy = inverted subtraction borrow

    // "Load" Mod into X4, X5, X6, X0
    mov     X_4, 0x00000000ffffffff
    mov     X_5, 0xffffffff00000000
    mov     X_6, 0xfffffffffffffffe
    mov     X_0, 0xffffffffffffffff

    subs     X_4, X_15,  X_4
    sbcs     X_5, X_16,  X_5
    sbcs     X_6,  X_9,  X_6
    sbcs     X_7, X_10,  X_0
    sbcs    X_14, X_11,  X_0
    sbcs     X_0, X_12,  X_0

    // Choose between the two
    // addition carry = 1, then subtraction borrow = 1 and we pick the 2nd result.
    // addition carry = 0 and subtraction borrow = 0: pick 2nd result
    // addition carry = 0 and subtraction borrow = 1: pick first result

    // We set borrow condition (cc) when subtracting with carry from X_11
    // iff addition carry 0 and subtraction borrow 1
    sbcs    X_13, X_13, XZR

    csel    X_15, X_15,  X_4, cc
    csel    X_16, X_16,  X_5, cc
    stp     X_15, X_16, [X_3]

    csel     X_9,  X_9,  X_6, cc
    csel    X_10, X_10,  X_7, cc
    stp      X_9, X_10, [X_3, #16]

    csel    X_11, X_11, X_14, cc
    csel    X_12, X_12,  X_0, cc
    stp     X_11, X_12, [X_3, #32]

FUNCTION_END(ARM64EC_NAME_MANGLE(SymCryptFdefModMulMontgomeryP384Asm))

//VOID
//SYMCRYPT_CALL
//SymCryptFdefModSquareMontgomeryP384Asm(
//    _In_                            PCSYMCRYPT_MODULUS      pMod,
//    _In_                            PCSYMCRYPT_MODELEMENT   pSrc,
//    _Out_                           PSYMCRYPT_MODELEMENT    pDst );

// Note we specify 4 arguments to keep prolog of this and SymCryptFdefModMulMontgomeryP384Asm the same
FUNCTION_START(ARM64EC_NAME_MANGLE(SymCryptFdefModSquareMontgomeryP384Asm), 4, 17)

    // X_0 = pMod
    // X_1 = pSrc
    // X_2 = pDst

    mov     X_3, X_2
    mov     X_2, X_1

    // Just jump into multiply, similar to SymCryptWipeAsm jumping into memset.

    b       ARM64EC_NAME_MANGLE(SymCryptFdefModMulMontgomeryP384AsmInternal)

FUNCTION_END(ARM64EC_NAME_MANGLE(SymCryptFdefModSquareMontgomeryP384Asm))

//VOID
//SYMCRYPT_CALL
//SymCryptFdefMontgomeryReduceAsm(
//    _In_                            PCSYMCRYPT_MODULUS      pmMod,
//    _Inout_                         PUINT32                 pSrc,
//    _Out_                           PUINT32                 pDst )
//
// Register assignments
//       X_0  = pMod (moving forward one *digit* every inner loop)
//       X_1  = pSrc (moving forward one *digit* every inner loop)
//       X_2  = pDst (used only in the end for subtract / result)
//       X_3  = byte count of pSrc and pMod (sometimes byte count - 1 digit of bytes)
//       X_4  = word count of pSrc
//       X_5  = Inv64 of the modulus
//       X_6  = m = pSrc[i]*Inv64
//       X_7  = hc = high carry variable
//       X_8-X_19 = temporaries
//       X_20 = c
//       X_21 = Stored byte count of pSrc

FUNCTION_START(ARM64EC_NAME_MANGLE(SymCryptFdefMontgomeryReduceAsm), 3, 22)

    ldr     W_4, [X_0, #SymCryptModulusNdigitsOffsetArm64]  // # of Digits
    ldr     X_5, [X_0, #SymCryptModulusInv64OffsetArm64]    // Inv64 of modulus
    add     X_0, X_0, #SymCryptModulusValueOffsetArm64      // pMod

    lsl     X_3, X_4, #5                // Multiply by 32 to get the number of bytes
    lsl     X_4, X_4, #2                // Multiply by 4 to get the number of words

    sub     X_3, X_3, #32               // offset the byte count to make it easy to restore pointers

    mov     X_7, xzr                    // Set hc to 0
    mov     X_21, X_3                   // Store the byte count for later

    //
    // Main loop
    //
LABEL(SymCryptFdefMontgomeryReduceAsmOuter)
    ldp     X_16, X_17, [X_1]           // pSrc[i+0], pSrc[i+1]
    mul     X_6, X_16, X_5              // <63:0> bits of pSrc[i]*Inv64 = m

    ldp     X_8,  X_9,  [X_0]           // pMod[0], pMod[1]
    umulh   X_8,  X_6, X_8              // Bits <127:64> of m*pMod[0]
    subs    xzr,  X_16, #1              // Subtract 1 from pSrc[i+0] (generate a carry iff pSrc[i] is non-zero)

    mul     X_13, X_6, X_9              // Bits <63:0> of m*pMod[1]
    umulh   X_9,  X_6, X_9              // Bits <127:64> of m*pMod[1]
    adcs    X_8,  X_8,  X_13            // Adding the previous word (if there was a carry from the last addition it is added)

    ldp     X_10, X_11, [X_0, #16]      // pMod[2], pMod[3]
    mul     X_14, X_6, X_10             // Bits <63:0> of m*pMod[2]
    umulh   X_10, X_6, X_10             // Bits <127:64> of m*pMod[2]
    adcs    X_9,  X_9,  X_14            // Adding the previous word (if there was a carry from the last addition it is added)

    ldp     X_18, X_19, [X_1, #16]      // pSrc[i+2], pSrc[i+3]
    mul     X_15, X_6, X_11             // Bits <63:0> of m*pMod[3]
    umulh   X_11, X_6, X_11             // Bits <127:64> of m*pMod[3]
    adcs    X_10, X_10, X_15            // Adding the previous word (if there was a carry from the last addition it is added)

    adc     X_20, X_11, xzr             // Add the carry if any

    // ( X_20, X_10, X_9, X_8, ___ ) = (( pMod[3], pMod[2], pMod[1], pMod[0] ) * m)
    // We do not compute this --^ because (m*pMod[0] + pSrc[i]) == 0. We already accounted for the carry above.

    adds    X_17, X_17, X_8             // Adding pSrc[i+1]
    adcs    X_18, X_18, X_9             // Adding pSrc[i+2]
    adcs    X_19, X_19, X_10            // Adding pSrc[i+3]

    stp     xzr,  X_17, [X_1]           // pSrc[i+0], pSrc[i+1]
    stp     X_18, X_19, [X_1, #16]      // pSrc[i+2], pSrc[i+3]

    cbz    X_3, SymCryptFdefMontgomeryReduceAsmInnerEnd

LABEL(SymCryptFdefMontgomeryReduceAsmInner)
    // Invariant - X_20 (c) + carry flag is a value in the range [0, 2^64-1]
    // We could always adc X_20, X_20, xzr before loop entry, but this is a wasted instruction
    // vs. adcs with X_20 below

    ldp     X_8,  X_9,  [X_0, #32]!     // pMod[j+0], pMod[j+1]
    mul     X_12, X_6, X_8              // Bits <63:0> of m*pMod[j]
    umulh   X_8,  X_6, X_8              // Bits <127:64> of m*pMod[j]
    adcs    X_12, X_20, X_12            // Adding the previous word (if there was a carry from the last addition it is added)

    mul     X_13, X_6, X_9              // Bits <63:0> of m*pMod[j+1]
    umulh   X_9,  X_6, X_9              // Bits <127:64> of m*pMod[j+1]
    ldp     X_16, X_17, [X_1, #32]!     // pSrc[i+j+0], pSrc[i+j+1]
    adcs    X_8,  X_8,  X_13            // Adding the previous word (if there was a carry from the last addition it is added)

    ldp     X_10, X_11, [X_0, #16]      // pMod[j+2], pMod[j+3]
    mul     X_14, X_6, X_10             // Bits <63:0> of m*pMod[j+2]
    umulh   X_10, X_6, X_10             // Bits <127:64> of m*pMod[j+2]
    adcs    X_9,  X_9,  X_14            // Adding the previous word (if there was a carry from the last addition it is added)

    ldp     X_18, X_19, [X_1, #16]      // pSrc[i+j+2], pSrc[i+j+3]
    mul     X_15, X_6, X_11             // Bits <63:0> of m*pMod[j+3]
    umulh   X_11, X_6, X_11             // Bits <127:64> of m*pMod[j+3]
    adcs    X_10, X_10, X_15            // Adding the previous word (if there was a carry from the last addition it is added)

    adc     X_20, X_11, xzr             // Add the carry if any

    // ( X_20, X_10, X_9, X_8, X_12 ) = (( pMod[j+3], pMod[j+2], pMod[j+1], pMod[j+0] ) * m) + c

    adds    X_16, X_16, X_12            // Adding pSrc[i+j+0]
    adcs    X_17, X_17, X_8             // Adding pSrc[i+j+1]
    adcs    X_18, X_18, X_9             // Adding pSrc[i+j+2]
    adcs    X_19, X_19, X_10            // Adding pSrc[i+j+3]

    stp     X_16, X_17, [X_1]           // pSrc[i+j+0], pSrc[i+j+1]
    stp     X_18, X_19, [X_1, #16]      // pSrc[i+j+2], pSrc[i+j+3]

    sub     X_3, X_3, #32               // Move one digit up
    cbnz    X_3, SymCryptFdefMontgomeryReduceAsmInner

LABEL(SymCryptFdefMontgomeryReduceAsmInnerEnd)

    ldr     X_8, [X_1, #32]             // pSrc[nWords]
    adcs    X_20, X_20, X_7             // c + hc
    adc     X_7, xzr, xzr               // Add the carry if any

    adds    X_20, X_20, X_8             // c + hc + pSrc[nWords]
    adc     X_7, X_7, xzr               // Add the carry if any and store into hc

    str     X_20, [X_1, #32]            // pSrc[nWords] = c

    subs    X_4, X_4, #1                // Move one word up

    sub     X_0, X_0, X_21              // Restore pMod pointer (subtract byte count)
    sub     X_1, X_1, X_21              // Restore pSrc pointer (subtract byte count)
    add     X_1, X_1, #8                // Move pSrc pointer one word up

    mov     X_3, X_21                   // Restore the byte counter

    bne     SymCryptFdefMontgomeryReduceAsmOuter

    //
    // Subtraction
    //
    add     X_3, X_3, #32           // restore the full byte count for loops using unconditional pre-indexing
    mov     X_21, X_3               // Store the byte count for later

    sub     X_0, X_0, #32           // offset pMod so we can use pre-increment form of loads
    sub     X_1, X_1, #32           // offset pSrc so we can use pre-increment form of loads
    sub     X_2, X_2, #32           // offset pDst so we can use pre-increment form of loads
    mov     X_14, X_2               // Store pDst pointer

    // Prepare the pointers for subtract
    mov     X_10, X_7               // X_10 = hc
    subs    X_4, X_4, X_4           // Set the carry flag (i.e. no borrow)

LABEL(SymCryptFdefMontgomeryReduceRawSubAsmLoop)
    sub     X_3, X_3, #32           // Decrement the byte count by 32
    // borrow is in the carry flag (flipped)

    ldp     X_4, X_6, [X_1, #32]!   // Load two words of pSrc
    ldp     X_5, X_7, [X_0, #32]!   // Load two words of pMod
    sbcs    X_4, X_4, X_5
    sbcs    X_6, X_6, X_7
    stp     X_4, X_6, [X_2, #32]!   // Store the result in the destination

    ldp     X_4, X_6, [X_1, #16]    // Load two words of pSrc
    ldp     X_5, X_7, [X_0, #16]    // Load two words of pMod
    sbcs    X_4, X_4, X_5
    sbcs    X_6, X_6, X_7
    stp     X_4, X_6, [X_2, #16]    // Store the result in the destination

    cbnz    X_3, SymCryptFdefMontgomeryReduceRawSubAsmLoop

    cset    X_0, cc                 // If the carry is clear (borrow), set the return value to 1

    orr     X_11, X_10, X_0         // X_11 = hc|d

    // Prepare the pointers for masked copy
    sub     X_0, X_1, X_21          // Restore pSrc pointer (subtract byte count)
    mov     X_1, X_14               // pDst

    mov     X_2, X_21               // Restore the byte counter
    subs    X_4, X_10, X_11         // If (X_11 > X_10) clear the carry flag (i.e. borrow)

LABEL(SymCryptFdefMontgomeryReduceMaskedCopyAsmLoop)
    sub     X_2, X_2, #32           // decrement the byte count by 32

    ldp     X_4, X_6, [X_0, #32]!   // Load two words of the source
    ldp     X_5, X_7, [X_1, #32]!   // Load two words of the destination
    csel    X_4, X_4, X_5, cc       // If the carry is clear, select the source operands
    csel    X_6, X_6, X_7, cc
    stp     X_4, X_6, [X_1]         // Store the two words in the destination

    ldp     X_4, X_6, [X_0, #16]
    ldp     X_5, X_7, [X_1, #16]
    csel    X_4, X_4, X_5, cc
    csel    X_6, X_6, X_7, cc
    stp     X_4, X_6, [X_1, #16]

    cbnz    X_2, SymCryptFdefMontgomeryReduceMaskedCopyAsmLoop

    // Done, no return value

FUNCTION_END(ARM64EC_NAME_MANGLE(SymCryptFdefMontgomeryReduceAsm))

MACRO_START(MULADD_LOADSTORE18, pS, pM, pD, K, Tc, T0, T1, T2, T3, T4, T5)
    // Tc:D[3:0] = (M[3:0] * K) + S[3:0] + Tc
    //
    // QH = K
    // T0..T5 = scratch
    // Tc is carry in at start and carry out at end (in [0,2^64-1])

    // Tc:T[5:2] = S[3:0] + (K * M odd) + Tc
    ldp     T2, T3, [pS]        // load S[0], S[1]
    adds    T2, T2, Tc

    ldr     T0, [pM, #8]
    mul     T1,  K, T0
    adcs    T3, T3, T1
    umulh   T0,  K, T0
    ldp     T4, T5, [pS, #16]   // load S[2], S[3]
    adcs    T4, T4, T0

    ldr     T0, [pM, #24]
    mul     T1,  K, T0
    adcs    T5, T5, T1
    umulh   Tc,  K, T0
    adc     Tc, Tc, XZR

    // Tc:D[3:0] = Tc:T[5:2] + (K * M even)
    ldr     T0, [pM]
    mul     T1,  K, T0
    adds    T2, T2, T1
    umulh   T0,  K, T0
    adcs    T3, T3, T0
    stp     T2, T3, [pD]        // store D[0], D[1]

    ldr     T0, [pM, #16]
    mul     T1,  K, T0
    adcs    T4, T4, T1
    umulh   T0,  K, T0
    adcs    T5, T5, T0
    stp     T4, T5, [pD, #16]   // store D[2], D[3]

    adc     Tc, Tc, XZR
MACRO_END()

MACRO_START(SHIFTRIGHT2, pD, index, shrVal, shrMask, shlVal, Tcin, Tcout, T0, T1)
    // T0:Tcout = D[index + 1:index]
    // D[index + 1] = Tcin:T0 >> shrVal (== ((T0>>shrVal)&shrMask) | (Tcin<<shlVal))
    // D[index] = T0:Tcout >> shrVal
    //
    // shrVal in [1,64]
    // shrMask = (shrVal == 64) ? 0 : -1
    // shlVal = 64-shrVal
    // 
    // T0, T1 = scratch
    // Value of Tcin is bits to shift in the top at start
    // Value of Tcout is bits to shift into next macro invocation at end

    ldp     Tcout, T0, [pD, #(index*8)]

    lsr     T1, T0, shrVal
    lsl     Tcin, Tcin, shlVal
    and     T1, T1, shrMask
    orr     T1, T1, Tcin

    lsr     Tcin, Tcout, shrVal
    lsl     T0, T0, shlVal
    and     Tcin, Tcin, shrMask
    orr     Tcin, Tcin, T0

    stp     Tcin, T1, [pD, #(index*8)]
MACRO_END()

//VOID
//SYMCRYPT_CALL
//SymCryptFdefModDivSmallPow2Asm(
//    _In_                            PCSYMCRYPT_MODULUS      pmMod,
//    _In_                            PCSYMCRYPT_MODELEMENT   peSrc,
//    _In_range_(1, 64)               UINT32                  exp,
//    _Out_                           PSYMCRYPT_MODELEMENT    peDst );

FUNCTION_START(ARM64EC_NAME_MANGLE(SymCryptFdefModDivSmallPow2Asm), 4, 14)
    ldr     X_7, [X_1]
    ldr     X_5, [X_0, #SymCryptModulusInv64OffsetArm64]    // Inv64 of modulus

    mul     X_7, X_7, X_5   // <63:0> bits of pSrc[0]*Inv64
                            // this is the multiple of the modulus that must be added to peSrc
                            // s.t. the least significant **64** bits are all zero

    // Form bitmask to mask out bottom exp bits from multiplication result
    mov     X_6, #-1
    neg     X_5, X_2
    lsr     X_6, X_6, X_5   // mask = -1 >> (-exp % 64)
                            //      = 0xffffffffffffffff >> (64-exp)
                            //      = (((UINT65)1)<<exp)-1

    and     X_7, X_7, X_6   // Extract the least significant exp bits from X_7 to produce K
                            // K is the minimal multiple of the modulus that when added to peSrc
                            // sets the least significant **exp** bits to zero

    ldr     W_4, [X_0, #SymCryptModulusNdigitsOffsetArm64]  // # of Digits, used directly as loop counter
    add     X_5, X_0, #SymCryptModulusValueOffsetArm64      // pointer to modulus value

    eor     X_6, X_6, X_6   // zero one word carry

LABEL(SymCryptFdefModDivSmallPow2AsmMulAddLoop)
    // Set peDst = peSrc + (K * mod)
    // Also has up to 64b of carry out the top which is stored in Q7 at the end of the loop
    //
    // W_4  loop ctr (one iteration per digit)
    // X_7  K
    // X_1  running pointer peSrc inner loop (we directly modify X_1 as we only need to read peSrc once)
    // X_5  running pointer pMod inner loop
    // X_3  running pointer peDst inner loop (we directly modify X_3 as we read/write peDst in reverse in second loop)
    // X_6  one word carry
    // X_8..X_13 scratch

    MULADD_LOADSTORE18 X_1, X_5, X_3, X_7, X_6, X_8, X_9, X10, X_11, X_12, X_13

    // Move on to the next digit
    add     X_1, X_1, #32
    add     X_5, X_5, #32
    add     X_3, X_3, #32

    sub     W_4, W_4, #1
    cbnz    W_4, SymCryptFdefModDivSmallPow2AsmMulAddLoop

    ldr     W_0, [X_0, #SymCryptModulusNdigitsOffsetArm64]  // # of Digits, used directly as loop counter
    mov     X_1, #64
    subs    X_1, X_1, X_2   // shlVal = 64-exp
    csetm   X_4, ne         // shrMask = ((exp != 64) ? -1 : 0) = ((exp == 64) ? 0 : -1)

    sub     X_3, X_3, #32  // X_3 points to the most significant digit of peDst

LABEL(SymCryptFdefModDivSmallPow2AsmShiftRightLoop)
    // Set peDst = peDst >> exp
    // We work backwards (from MSB to LSB) so we avoid having to do special handling of the one word
    // carry out of the top of the multiply add loop
    //
    // W_0  loop ctr (one iteration per digit)
    // X_1  shlVal
    // X_4  shrMask
    // X_2  shrVal
    // X_3  running pointer peDst inner loop (decreasing)
    // X_6  one word carry even
    // X_7  one word carry odd
    // X_8, X_9 scratch

    SHIFTRIGHT2 X_3, 2, X_2, X_4, X_1, X_6, X_7, X_8, X_9
    SHIFTRIGHT2 X_3, 0, X_2, X_4, X_1, X_7, X_6, X_8, X_9
        
    sub     X_3, X_3, #32

    sub     W_0, W_0, #1
    cbnz    W_0, SymCryptFdefModDivSmallPow2AsmShiftRightLoop

FUNCTION_END(ARM64EC_NAME_MANGLE(SymCryptFdefModDivSmallPow2Asm))

    FILE_END()
