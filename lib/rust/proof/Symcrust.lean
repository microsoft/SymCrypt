-- THIS FILE WAS AUTOMATICALLY GENERATED BY AENEAS
-- [symcrust]
import Aeneas
open Aeneas.Std
set_option linter.dupNamespace false
set_option linter.hashCommand false
set_option linter.unusedVariables false

namespace symcrust

/- [symcrust::ntt::MLWE_POLYNOMIAL_COEFFICIENTS]
   Source: 'src/ntt.rs', lines 52:0-52:48 -/
def ntt.MLWE_POLYNOMIAL_COEFFICIENTS_body : Result Usize := Result.ok 256#usize
def ntt.MLWE_POLYNOMIAL_COEFFICIENTS : Usize :=
  eval_global ntt.MLWE_POLYNOMIAL_COEFFICIENTS_body

/- [symcrust::ntt::MATRIX_MAX_NROWS]
   Source: 'src/ntt.rs', lines 64:0-64:34 -/
def ntt.MATRIX_MAX_NROWS_body : Result Usize := Result.ok 4#usize
def ntt.MATRIX_MAX_NROWS : Usize := eval_global ntt.MATRIX_MAX_NROWS_body

/- [symcrust::ntt::MATRIX]
   Source: 'src/ntt.rs', lines 82:0-85:1 -/
structure ntt.MATRIX where
  nRows : Usize
  apPolyElements : Array (Array U16 256#usize) 16#usize

/- [symcrust::ntt::KEY_MAX_SIZEOF_ENCODED_T]
   Source: 'src/ntt.rs', lines 91:0-91:45 -/
def ntt.KEY_MAX_SIZEOF_ENCODED_T_body : Result Usize := Result.ok 1536#usize
def ntt.KEY_MAX_SIZEOF_ENCODED_T : Usize :=
  eval_global ntt.KEY_MAX_SIZEOF_ENCODED_T_body

/- [symcrust::ntt::INTERNAL_PARAMS]
   Source: 'src/ntt.rs', lines 93:0-110:1 -/
structure ntt.INTERNAL_PARAMS where
  params : U32
  cbPolyElement : U32
  cbVector : U32
  cbMatrix : U32
  nRows : U8
  nEta1 : U8
  nEta2 : U8
  nBitsOfU : U8
  nBitsOfV : U8

/- [symcrust::ntt::KEY]
   Source: 'src/ntt.rs', lines 112:0-141:1 -/
structure ntt.KEY where
  fAlgorithmInfo : U32
  params : ntt.INTERNAL_PARAMS
  cbTotalSize : U32
  hasPrivateSeed : Bool
  hasPrivateKey : Bool
  privateSeed : Array U8 32#usize
  privateRandom : Array U8 32#usize
  publicSeed : Array U8 32#usize
  pmAtranspose : ntt.MATRIX
  pvt : Slice (Array U16 256#usize)
  pvs : Slice (Array U16 256#usize)
  encodedT : Array U8 1536#usize
  encapsKeyHash : Array U8 32#usize

/- [symcrust::ntt::Q]
   Source: 'src/ntt.rs', lines 147:0-147:20 -/
def ntt.Q_body : Result U32 := Result.ok 3329#u32
def ntt.Q : U32 := eval_global ntt.Q_body

/- [symcrust::ntt::SIZEOF_MAX_CIPHERTEXT]
   Source: 'src/ntt.rs', lines 156:0-156:42 -/
def ntt.SIZEOF_MAX_CIPHERTEXT_body : Result Usize := Result.ok 1568#usize
def ntt.SIZEOF_MAX_CIPHERTEXT : Usize :=
  eval_global ntt.SIZEOF_MAX_CIPHERTEXT_body

/- [symcrust::ntt::SIZEOF_AGREED_SECRET]
   Source: 'src/ntt.rs', lines 157:0-157:39 -/
def ntt.SIZEOF_AGREED_SECRET_body : Result Usize := Result.ok 32#usize
def ntt.SIZEOF_AGREED_SECRET : Usize :=
  eval_global ntt.SIZEOF_AGREED_SECRET_body

/- [symcrust::ntt::SIZEOF_ENCAPS_RANDOM]
   Source: 'src/ntt.rs', lines 158:0-158:39 -/
def ntt.SIZEOF_ENCAPS_RANDOM_body : Result Usize := Result.ok 32#usize
def ntt.SIZEOF_ENCAPS_RANDOM : Usize :=
  eval_global ntt.SIZEOF_ENCAPS_RANDOM_body

/- [symcrust::ntt::INTERNAL_COMPUTATION_TEMPORARIES]
   Source: 'src/ntt.rs', lines 177:0-185:1 -/
structure ntt.INTERNAL_COMPUTATION_TEMPORARIES where
  abVectorBuffer0 : Array (Array U16 256#usize) 4#usize
  abVectorBuffer1 : Array (Array U16 256#usize) 4#usize
  abPolyElementBuffer0 : Array U16 256#usize
  abPolyElementBuffer1 : Array U16 256#usize
  abPolyElementAccumulatorBuffer : Array U32 256#usize

/- [symcrust::ntt::Rlog2]
   Source: 'src/ntt.rs', lines 216:0-216:22 -/
def ntt.Rlog2_body : Result U32 := Result.ok 16#u32
def ntt.Rlog2 : U32 := eval_global ntt.Rlog2_body

/- [symcrust::ntt::Rmask]
   Source: 'src/ntt.rs', lines 217:0-217:26 -/
def ntt.Rmask_body : Result U32 := Result.ok 65535#u32
def ntt.Rmask : U32 := eval_global ntt.Rmask_body

/- [symcrust::ntt::NegQInvModR]
   Source: 'src/ntt.rs', lines 220:0-220:30 -/
def ntt.NegQInvModR_body : Result U32 := Result.ok 3327#u32
def ntt.NegQInvModR : U32 := eval_global ntt.NegQInvModR_body

/- [symcrust::ntt::Rsqr]
   Source: 'src/ntt.rs', lines 223:0-223:23 -/
def ntt.Rsqr_body : Result U32 := Result.ok 1353#u32
def ntt.Rsqr : U32 := eval_global ntt.Rsqr_body

/- [symcrust::ntt::RsqrTimesNegQInvModR]
   Source: 'src/ntt.rs', lines 225:0-225:40 -/
def ntt.RsqrTimesNegQInvModR_body : Result U32 := Result.ok 44983#u32
def ntt.RsqrTimesNegQInvModR : U32 := eval_global ntt.RsqrTimesNegQInvModR_body

/- [symcrust::ntt::MlKemZetaBitRevTimesR]
   Source: 'src/ntt.rs', lines 240:0-257:2 -/
def ntt.MlKemZetaBitRevTimesR_body : Result (Array U16 128#usize) :=
  Result.ok
  (Array.make 128#usize [
    2285#u16, 2571#u16, 2970#u16, 1812#u16, 1493#u16, 1422#u16, 287#u16,
    202#u16, 3158#u16, 622#u16, 1577#u16, 182#u16, 962#u16, 2127#u16, 1855#u16,
    1468#u16, 573#u16, 2004#u16, 264#u16, 383#u16, 2500#u16, 1458#u16,
    1727#u16, 3199#u16, 2648#u16, 1017#u16, 732#u16, 608#u16, 1787#u16,
    411#u16, 3124#u16, 1758#u16, 1223#u16, 652#u16, 2777#u16, 1015#u16,
    2036#u16, 1491#u16, 3047#u16, 1785#u16, 516#u16, 3321#u16, 3009#u16,
    2663#u16, 1711#u16, 2167#u16, 126#u16, 1469#u16, 2476#u16, 3239#u16,
    3058#u16, 830#u16, 107#u16, 1908#u16, 3082#u16, 2378#u16, 2931#u16,
    961#u16, 1821#u16, 2604#u16, 448#u16, 2264#u16, 677#u16, 2054#u16,
    2226#u16, 430#u16, 555#u16, 843#u16, 2078#u16, 871#u16, 1550#u16, 105#u16,
    422#u16, 587#u16, 177#u16, 3094#u16, 3038#u16, 2869#u16, 1574#u16,
    1653#u16, 3083#u16, 778#u16, 1159#u16, 3182#u16, 2552#u16, 1483#u16,
    2727#u16, 1119#u16, 1739#u16, 644#u16, 2457#u16, 349#u16, 418#u16, 329#u16,
    3173#u16, 3254#u16, 817#u16, 1097#u16, 603#u16, 610#u16, 1322#u16,
    2044#u16, 1864#u16, 384#u16, 2114#u16, 3193#u16, 1218#u16, 1994#u16,
    2455#u16, 220#u16, 2142#u16, 1670#u16, 2144#u16, 1799#u16, 2051#u16,
    794#u16, 1819#u16, 2475#u16, 2459#u16, 478#u16, 3221#u16, 3021#u16,
    996#u16, 991#u16, 958#u16, 1869#u16, 1522#u16, 1628#u16
    ])
def ntt.MlKemZetaBitRevTimesR : Array U16 128#usize :=
  eval_global ntt.MlKemZetaBitRevTimesR_body

/- [symcrust::ntt::MlKemZetaBitRevTimesRTimesNegQInvModR]
   Source: 'src/ntt.rs', lines 263:0-280:2 -/
def ntt.MlKemZetaBitRevTimesRTimesNegQInvModR_body
  : Result (Array U16 128#usize) :=
  Result.ok
  (Array.make 128#usize [
    19#u16, 34037#u16, 50790#u16, 64748#u16, 52011#u16, 12402#u16, 37345#u16,
    16694#u16, 20906#u16, 37778#u16, 3799#u16, 15690#u16, 54846#u16, 64177#u16,
    11201#u16, 34372#u16, 5827#u16, 48172#u16, 26360#u16, 29057#u16, 59964#u16,
    1102#u16, 44097#u16, 26241#u16, 28072#u16, 41223#u16, 10532#u16, 56736#u16,
    47109#u16, 56677#u16, 38860#u16, 16162#u16, 5689#u16, 6516#u16, 64039#u16,
    34569#u16, 23564#u16, 45357#u16, 44825#u16, 40455#u16, 12796#u16,
    38919#u16, 49471#u16, 12441#u16, 56401#u16, 649#u16, 25986#u16, 37699#u16,
    45652#u16, 28249#u16, 15886#u16, 8898#u16, 28309#u16, 56460#u16, 30198#u16,
    47286#u16, 52109#u16, 51519#u16, 29155#u16, 12756#u16, 48704#u16,
    61224#u16, 24155#u16, 17914#u16, 334#u16, 54354#u16, 11477#u16, 52149#u16,
    32226#u16, 14233#u16, 45042#u16, 21655#u16, 27738#u16, 52405#u16,
    64591#u16, 4586#u16, 14882#u16, 42443#u16, 59354#u16, 60043#u16, 33525#u16,
    32502#u16, 54905#u16, 35218#u16, 36360#u16, 18741#u16, 28761#u16,
    52897#u16, 18485#u16, 45436#u16, 47975#u16, 47011#u16, 14430#u16,
    46007#u16, 5275#u16, 12618#u16, 31183#u16, 45239#u16, 40101#u16, 63390#u16,
    7382#u16, 50180#u16, 41144#u16, 32384#u16, 20926#u16, 6279#u16, 54590#u16,
    14902#u16, 41321#u16, 11044#u16, 48546#u16, 51066#u16, 55200#u16,
    21497#u16, 7933#u16, 20198#u16, 22501#u16, 42325#u16, 54629#u16, 17442#u16,
    33899#u16, 23859#u16, 36892#u16, 20257#u16, 41538#u16, 57779#u16,
    17422#u16, 42404#u16
    ])
def ntt.MlKemZetaBitRevTimesRTimesNegQInvModR : Array U16 128#usize :=
  eval_global ntt.MlKemZetaBitRevTimesRTimesNegQInvModR_body

/- [symcrust::ntt::zetaTwoTimesBitRevPlus1TimesR]
   Source: 'src/ntt.rs', lines 286:0-303:2 -/
def ntt.zetaTwoTimesBitRevPlus1TimesR_body : Result (Array U16 128#usize) :=
  Result.ok
  (Array.make 128#usize [
    2226#u16, 1103#u16, 430#u16, 2899#u16, 555#u16, 2774#u16, 843#u16,
    2486#u16, 2078#u16, 1251#u16, 871#u16, 2458#u16, 1550#u16, 1779#u16,
    105#u16, 3224#u16, 422#u16, 2907#u16, 587#u16, 2742#u16, 177#u16, 3152#u16,
    3094#u16, 235#u16, 3038#u16, 291#u16, 2869#u16, 460#u16, 1574#u16,
    1755#u16, 1653#u16, 1676#u16, 3083#u16, 246#u16, 778#u16, 2551#u16,
    1159#u16, 2170#u16, 3182#u16, 147#u16, 2552#u16, 777#u16, 1483#u16,
    1846#u16, 2727#u16, 602#u16, 1119#u16, 2210#u16, 1739#u16, 1590#u16,
    644#u16, 2685#u16, 2457#u16, 872#u16, 349#u16, 2980#u16, 418#u16, 2911#u16,
    329#u16, 3000#u16, 3173#u16, 156#u16, 3254#u16, 75#u16, 817#u16, 2512#u16,
    1097#u16, 2232#u16, 603#u16, 2726#u16, 610#u16, 2719#u16, 1322#u16,
    2007#u16, 2044#u16, 1285#u16, 1864#u16, 1465#u16, 384#u16, 2945#u16,
    2114#u16, 1215#u16, 3193#u16, 136#u16, 1218#u16, 2111#u16, 1994#u16,
    1335#u16, 2455#u16, 874#u16, 220#u16, 3109#u16, 2142#u16, 1187#u16,
    1670#u16, 1659#u16, 2144#u16, 1185#u16, 1799#u16, 1530#u16, 2051#u16,
    1278#u16, 794#u16, 2535#u16, 1819#u16, 1510#u16, 2475#u16, 854#u16,
    2459#u16, 870#u16, 478#u16, 2851#u16, 3221#u16, 108#u16, 3021#u16, 308#u16,
    996#u16, 2333#u16, 991#u16, 2338#u16, 958#u16, 2371#u16, 1869#u16,
    1460#u16, 1522#u16, 1807#u16, 1628#u16, 1701#u16
    ])
def ntt.zetaTwoTimesBitRevPlus1TimesR : Array U16 128#usize :=
  eval_global ntt.zetaTwoTimesBitRevPlus1TimesR_body

/- [symcrust::ntt::SymCryptMlKemModAdd]:
   Source: 'src/ntt.rs', lines 306:0-316:1 -/
def ntt.SymCryptMlKemModAdd (a : U32) (b : U32) : Result U32 :=
  do
  massert (a < ntt.Q)
  massert (b < ntt.Q)
  let i ← a + b
  let res ← i - ntt.Q
  let i1 ← res >>> 16#i32
  if i1 = 0#u32
  then
    do
    let i2 ← res >>> 16#i32
    let res1 ← res + ntt.Q &&& i2
    massert (res1 < ntt.Q)
    Result.ok res1
  else
    do
    let i2 ← res >>> 16#i32
    massert (i2 = 65535#u32)
    let i3 ← res >>> 16#i32
    let res1 ← res + ntt.Q &&& i3
    massert (res1 < ntt.Q)
    Result.ok res1

/- [symcrust::ntt::SymCryptMlKemModSub]:
   Source: 'src/ntt.rs', lines 318:0-328:1 -/
def ntt.SymCryptMlKemModSub (a : U32) (b : U32) : Result U32 :=
  do
  let i ← 2#u32 * ntt.Q
  massert (a < i)
  massert (b <= ntt.Q)
  let res ← a - b
  let i1 ← res >>> 16#i32
  if i1 = 0#u32
  then
    do
    let i2 ← res >>> 16#i32
    let res1 ← res + ntt.Q &&& i2
    massert (res1 < ntt.Q)
    Result.ok res1
  else
    do
    let i2 ← res >>> 16#i32
    massert (i2 = 65535#u32)
    let i3 ← res >>> 16#i32
    let res1 ← res + ntt.Q &&& i3
    massert (res1 < ntt.Q)
    Result.ok res1

/- [symcrust::ntt::SymCryptMlKemMontMul]:
   Source: 'src/ntt.rs', lines 330:0-343:1 -/
def ntt.SymCryptMlKemMontMul (a : U32) (b : U32) (bMont : U32) : Result U32 :=
  do
  massert (a < ntt.Q)
  massert (b < ntt.Q)
  massert (bMont <= ntt.Rmask)
  let i ← b * ntt.NegQInvModR
  massert (bMont = i &&& ntt.Rmask)
  let res ← a * b
  let i1 ← a * bMont
  let i2 ← i1 &&& ntt.Rmask * ntt.Q
  let res1 ← res + i2
  massert (res1 &&& ntt.Rmask = 0#u32)
  let res2 ← res1 >>> ntt.Rlog2
  ntt.SymCryptMlKemModSub res2 ntt.Q

/- [symcrust::ntt::SymCryptMlKemPolyElementNTTLayerC::inner_loop]: loop 0:
   Source: 'src/ntt.rs', lines 44:8-368:13 -/
divergent def ntt.SymCryptMlKemPolyElementNTTLayerC.inner_loop_loop
  (peSrc : Array U16 256#usize) (len : Usize) (start : Usize)
  (twiddleFactor : U32) (twiddleFactorMont : U32) (j : Usize) :
  Result (Array U16 256#usize)
  :=
  if j < len
  then
    do
    let i ← start + j
    let i1 ← Array.index_usize peSrc i
    let c0 ← core.convert.IntoFrom.into core.convert.FromU32U16 i1
    massert (c0 < ntt.Q)
    let i2 ← start + j
    let i3 ← i2 + len
    let i4 ← Array.index_usize peSrc i3
    let c1 ← core.convert.IntoFrom.into core.convert.FromU32U16 i4
    massert (c1 < ntt.Q)
    let c1TimesTwiddle ←
      ntt.SymCryptMlKemMontMul c1 twiddleFactor twiddleFactorMont
    let c11 ← ntt.SymCryptMlKemModSub c0 c1TimesTwiddle
    let c01 ← ntt.SymCryptMlKemModAdd c0 c1TimesTwiddle
    let i5 ← start + j
    let (_, index_mut_back) ← Array.index_mut_usize peSrc i5
    let i6 ← Scalar.cast .U16 c01
    let i7 ← start + j
    let i8 ← i7 + len
    let peSrc1 := index_mut_back i6
    let (_, index_mut_back1) ← Array.index_mut_usize peSrc1 i8
    let i9 ← Scalar.cast .U16 c11
    let j1 ← j + 1#usize
    let peSrc2 := index_mut_back1 i9
    ntt.SymCryptMlKemPolyElementNTTLayerC.inner_loop_loop peSrc2 len start
      twiddleFactor twiddleFactorMont j1
  else Result.ok peSrc

/- [symcrust::ntt::SymCryptMlKemPolyElementNTTLayerC::inner_loop]:
   Source: 'src/ntt.rs', lines 354:8-369:9 -/
def ntt.SymCryptMlKemPolyElementNTTLayerC.inner_loop
  (peSrc : Array U16 256#usize) (len : Usize) (start : Usize)
  (twiddleFactor : U32) (twiddleFactorMont : U32) :
  Result (Array U16 256#usize)
  :=
  ntt.SymCryptMlKemPolyElementNTTLayerC.inner_loop_loop peSrc len start
    twiddleFactor twiddleFactorMont 0#usize

/- [symcrust::ntt::SymCryptMlKemPolyElementNTTLayerC]: loop 0:
   Source: 'src/ntt.rs', lines 44:8-371:5 -/
divergent def ntt.SymCryptMlKemPolyElementNTTLayerC_loop
  (peSrc : Array U16 256#usize) (k : Usize) (len : Usize) (start : Usize) :
  Result (Array U16 256#usize)
  :=
  if start < 256#usize
  then
    do
    let i ← Array.index_usize ntt.MlKemZetaBitRevTimesR k
    let twiddleFactor ← core.convert.IntoFrom.into core.convert.FromU32U16 i
    let i1 ← Array.index_usize ntt.MlKemZetaBitRevTimesRTimesNegQInvModR k
    let twiddleFactorMont ←
      core.convert.IntoFrom.into core.convert.FromU32U16 i1
    let k1 ← k + 1#usize
    let peSrc1 ←
      ntt.SymCryptMlKemPolyElementNTTLayerC.inner_loop peSrc len start
        twiddleFactor twiddleFactorMont
    let i2 ← 2#usize * len
    let start1 ← start + i2
    ntt.SymCryptMlKemPolyElementNTTLayerC_loop peSrc1 k1 len start1
  else Result.ok peSrc

/- [symcrust::ntt::SymCryptMlKemPolyElementNTTLayerC]:
   Source: 'src/ntt.rs', lines 345:0-372:1 -/
def ntt.SymCryptMlKemPolyElementNTTLayerC
  (peSrc : Array U16 256#usize) (k : Usize) (len : Usize) :
  Result (Array U16 256#usize)
  :=
  ntt.SymCryptMlKemPolyElementNTTLayerC_loop peSrc k len 0#usize

/- [symcrust::ntt::SymCryptMlKemPolyElementINTTLayerC::inner_loop]: loop 0:
   Source: 'src/ntt.rs', lines 44:8-398:13 -/
divergent def ntt.SymCryptMlKemPolyElementINTTLayerC.inner_loop_loop
  (peSrc : Array U16 256#usize) (len : Usize) (start : Usize)
  (twiddleFactor : U32) (twiddleFactorMont : U32) (j : Usize) :
  Result (Array U16 256#usize)
  :=
  if j < len
  then
    do
    let i ← start + j
    let i1 ← Array.index_usize peSrc i
    let c0 ← core.convert.IntoFrom.into core.convert.FromU32U16 i1
    massert (c0 < ntt.Q)
    let i2 ← start + j
    let i3 ← i2 + len
    let i4 ← Array.index_usize peSrc i3
    let c1 ← core.convert.IntoFrom.into core.convert.FromU32U16 i4
    massert (c1 < ntt.Q)
    let tmp ← ntt.SymCryptMlKemModAdd c0 c1
    let c11 ← ntt.SymCryptMlKemModSub c1 c0
    let c12 ← ntt.SymCryptMlKemMontMul c11 twiddleFactor twiddleFactorMont
    let i5 ← start + j
    let (_, index_mut_back) ← Array.index_mut_usize peSrc i5
    let i6 ← Scalar.cast .U16 tmp
    let i7 ← start + j
    let i8 ← i7 + len
    let peSrc1 := index_mut_back i6
    let (_, index_mut_back1) ← Array.index_mut_usize peSrc1 i8
    let i9 ← Scalar.cast .U16 c12
    let j1 ← j + 1#usize
    let peSrc2 := index_mut_back1 i9
    ntt.SymCryptMlKemPolyElementINTTLayerC.inner_loop_loop peSrc2 len start
      twiddleFactor twiddleFactorMont j1
  else Result.ok peSrc

/- [symcrust::ntt::SymCryptMlKemPolyElementINTTLayerC::inner_loop]:
   Source: 'src/ntt.rs', lines 384:8-399:9 -/
def ntt.SymCryptMlKemPolyElementINTTLayerC.inner_loop
  (peSrc : Array U16 256#usize) (len : Usize) (start : Usize)
  (twiddleFactor : U32) (twiddleFactorMont : U32) :
  Result (Array U16 256#usize)
  :=
  ntt.SymCryptMlKemPolyElementINTTLayerC.inner_loop_loop peSrc len start
    twiddleFactor twiddleFactorMont 0#usize

/- [symcrust::ntt::SymCryptMlKemPolyElementINTTLayerC]: loop 0:
   Source: 'src/ntt.rs', lines 44:8-400:5 -/
divergent def ntt.SymCryptMlKemPolyElementINTTLayerC_loop
  (peSrc : Array U16 256#usize) (k : Usize) (len : Usize) (start : Usize) :
  Result (Array U16 256#usize)
  :=
  if start < 256#usize
  then
    do
    let i ← Array.index_usize ntt.MlKemZetaBitRevTimesR k
    let twiddleFactor ← core.convert.IntoFrom.into core.convert.FromU32U16 i
    let i1 ← Array.index_usize ntt.MlKemZetaBitRevTimesRTimesNegQInvModR k
    let twiddleFactorMont ←
      core.convert.IntoFrom.into core.convert.FromU32U16 i1
    let k1 ← k - 1#usize
    let peSrc1 ←
      ntt.SymCryptMlKemPolyElementINTTLayerC.inner_loop peSrc len start
        twiddleFactor twiddleFactorMont
    let i2 ← 2#usize * len
    let start1 ← start + i2
    ntt.SymCryptMlKemPolyElementINTTLayerC_loop peSrc1 k1 len start1
  else Result.ok peSrc

/- [symcrust::ntt::SymCryptMlKemPolyElementINTTLayerC]:
   Source: 'src/ntt.rs', lines 374:0-401:1 -/
def ntt.SymCryptMlKemPolyElementINTTLayerC
  (peSrc : Array U16 256#usize) (k : Usize) (len : Usize) :
  Result (Array U16 256#usize)
  :=
  ntt.SymCryptMlKemPolyElementINTTLayerC_loop peSrc k len 0#usize

/- [symcrust::ntt::SymCryptMlKemPolyElementNTTLayer]:
   Source: 'src/ntt.rs', lines 403:0-405:1 -/
def ntt.SymCryptMlKemPolyElementNTTLayer
  (peSrc : Array U16 256#usize) (k : Usize) (len : Usize) :
  Result (Array U16 256#usize)
  :=
  ntt.SymCryptMlKemPolyElementNTTLayerC peSrc k len

/- [symcrust::ntt::SymCryptMlKemPolyElementINTTLayer]:
   Source: 'src/ntt.rs', lines 407:0-409:1 -/
def ntt.SymCryptMlKemPolyElementINTTLayer
  (peSrc : Array U16 256#usize) (k : Usize) (len : Usize) :
  Result (Array U16 256#usize)
  :=
  ntt.SymCryptMlKemPolyElementINTTLayerC peSrc k len

/- [symcrust::ntt::SymCryptMlKemPolyElementMulAndAccumulate]: loop 0:
   Source: 'src/ntt.rs', lines 44:8-466:5 -/
divergent def ntt.SymCryptMlKemPolyElementMulAndAccumulate_loop
  (peSrc1 : Array U16 256#usize) (peSrc2 : Array U16 256#usize)
  (paDst : Array U32 256#usize) (i : Usize) :
  Result (Array U32 256#usize)
  :=
  do
  let i1 ← ntt.MLWE_POLYNOMIAL_COEFFICIENTS / 2#usize
  if i < i1
  then
    do
    let i2 ← 2#usize * i
    let i3 ← Array.index_usize peSrc1 i2
    let a0 ← core.convert.IntoFrom.into core.convert.FromU32U16 i3
    massert (a0 < ntt.Q)
    let i4 ← 2#usize * i
    let i5 ← i4 + 1#usize
    let i6 ← Array.index_usize peSrc1 i5
    let a1 ← core.convert.IntoFrom.into core.convert.FromU32U16 i6
    massert (a1 < ntt.Q)
    let i7 ← 2#usize * i
    let i8 ← Array.index_usize peSrc2 i7
    let b0 ← core.convert.IntoFrom.into core.convert.FromU32U16 i8
    massert (b0 < ntt.Q)
    let i9 ← 2#usize * i
    let i10 ← i9 + 1#usize
    let i11 ← Array.index_usize peSrc2 i10
    let b1 ← core.convert.IntoFrom.into core.convert.FromU32U16 i11
    massert (b1 < ntt.Q)
    let i12 ← 2#usize * i
    let i13 ← Array.index_usize paDst i12
    let c0 ← core.convert.IntoFrom.into (core.convert.FromSame U32) i13
    let i14 ← 3328#u32 * 3328#u32
    let i15 ← 3494#u32 * 3312#u32
    let i16 ← i14 + i15
    let i17 ← 3#u32 * i16
    massert (c0 <= i17)
    let i18 ← 2#usize * i
    let i19 ← i18 + 1#usize
    let i20 ← Array.index_usize paDst i19
    let c1 ← core.convert.IntoFrom.into (core.convert.FromSame U32) i20
    let i21 ← 3328#u32 * 3328#u32
    let i22 ← 3494#u32 * 3312#u32
    let i23 ← i21 + i22
    let i24 ← 3#u32 * i23
    massert (c1 <= i24)
    let a0b0 ← a0 * b0
    let a1b1 ← a1 * b1
    let a0b1 ← a0 * b1
    let a1b0 ← a1 * b0
    let i25 ← a1b1 * ntt.NegQInvModR
    let i26 ← i25 &&& ntt.Rmask * ntt.Q
    let i27 ← a1b1 + i26
    let a1b11 ← i27 >>> ntt.Rlog2
    massert (a1b11 <= 3494#u32)
    let i28 ← Array.index_usize ntt.zetaTwoTimesBitRevPlus1TimesR i
    let i29 ← Scalar.cast .U32 i28
    let a1b1zetapow ← a1b11 * i29
    let a0b01 ← a0b0 + a1b1zetapow
    let i30 ← 3328#u32 * 3328#u32
    let i31 ← 3494#u32 * 3312#u32
    let i32 ← i30 + i31
    massert (a0b01 <= i32)
    let a0b11 ← a0b1 + a1b0
    let i33 ← 2#u32 * 3328#u32
    let i34 ← i33 * 3328#u32
    massert (a0b11 <= i34)
    massert (ntt.MATRIX_MAX_NROWS <= 4#usize)
    let c01 ← c0 + a0b01
    let i35 ← 4#u32 * 3328#u32
    let i36 ← i35 * 3328#u32
    let i37 ← 4#u32 * 3494#u32
    let i38 ← i37 * 3312#u32
    let i39 ← i36 + i38
    massert (c01 < i39)
    let c11 ← c1 + a0b11
    let i40 ← 5#u32 * 3328#u32
    let i41 ← i40 * 3328#u32
    let i42 ← 3#u32 * 3494#u32
    let i43 ← i42 * 3312#u32
    let i44 ← i41 + i43
    massert (c11 < i44)
    let i45 ← 2#usize * i
    let (_, index_mut_back) ← Array.index_mut_usize paDst i45
    let i46 ← 2#usize * i
    let i47 ← i46 + 1#usize
    let paDst1 := index_mut_back c01
    let (_, index_mut_back1) ← Array.index_mut_usize paDst1 i47
    let i48 ← i + 1#usize
    let paDst2 := index_mut_back1 c11
    ntt.SymCryptMlKemPolyElementMulAndAccumulate_loop peSrc1 peSrc2 paDst2 i48
  else Result.ok paDst

/- [symcrust::ntt::SymCryptMlKemPolyElementMulAndAccumulate]:
   Source: 'src/ntt.rs', lines 411:0-467:1 -/
def ntt.SymCryptMlKemPolyElementMulAndAccumulate
  (peSrc1 : Array U16 256#usize) (peSrc2 : Array U16 256#usize)
  (paDst : Array U32 256#usize) :
  Result (Array U32 256#usize)
  :=
  ntt.SymCryptMlKemPolyElementMulAndAccumulate_loop peSrc1 peSrc2 paDst 0#usize

/- [symcrust::ntt::SymCryptMlKemMontgomeryReduceAndAddPolyElementAccumulatorToPolyElement]: loop 0:
   Source: 'src/ntt.rs', lines 44:8-501:5 -/
divergent def
  ntt.SymCryptMlKemMontgomeryReduceAndAddPolyElementAccumulatorToPolyElement_loop
  (paSrc : Array U32 256#usize) (peDst : Array U16 256#usize) (i : Usize) :
  Result ((Array U32 256#usize) × (Array U16 256#usize))
  :=
  if i < ntt.MLWE_POLYNOMIAL_COEFFICIENTS
  then
    do
    let a ← Array.index_usize paSrc i
    let i1 ← 3328#u32 * 3328#u32
    let i2 ← 3494#u32 * 3312#u32
    let i3 ← i1 + i2
    let i4 ← 4#u32 * i3
    massert (a <= i4)
    let (_, index_mut_back) ← Array.index_mut_usize paSrc i
    let i5 ← Array.index_usize peDst i
    let c ← core.convert.IntoFrom.into core.convert.FromU32U16 i5
    massert (c < ntt.Q)
    let i6 ← a * ntt.NegQInvModR
    let i7 ← i6 &&& ntt.Rmask * ntt.Q
    let i8 ← a + i7
    let a1 ← i8 >>> ntt.Rlog2
    massert (a1 <= 4711#u32)
    let c1 ← c + a1
    massert (c1 <= 8039#u32)
    let i9 ← 2#u32 * ntt.Q
    let c2 ← c1 - i9
    let i10 ← Scalar.cast .I32 ntt.Q
    let i11 ← (-2)#i32 * i10
    let i12 ← Scalar.cast .U32 i11
    if c2 >= i12
    then
      do
      let i13 ← c2 >>> 16#i32
      let c3 ← c2 + ntt.Q &&& i13
      let i14 ← Scalar.cast .I32 ntt.Q
      let i15 ← -. i14
      let i16 ← Scalar.cast .U32 i15
      if c3 >= i16
      then
        do
        let i17 ← c3 >>> 16#i32
        let c4 ← c3 + ntt.Q &&& i17
        massert (c4 < ntt.Q)
        let (_, index_mut_back1) ← Array.index_mut_usize peDst i
        let i18 ← Scalar.cast .U16 c4
        let i19 ← i + 1#usize
        let peDst1 := index_mut_back1 i18
        let paSrc1 := index_mut_back 0#u32
        ntt.SymCryptMlKemMontgomeryReduceAndAddPolyElementAccumulatorToPolyElement_loop
          paSrc1 peDst1 i19
      else
        do
        massert (c3 < ntt.Q)
        let i17 ← c3 >>> 16#i32
        let c4 ← c3 + ntt.Q &&& i17
        massert (c4 < ntt.Q)
        let (_, index_mut_back1) ← Array.index_mut_usize peDst i
        let i18 ← Scalar.cast .U16 c4
        let i19 ← i + 1#usize
        let peDst1 := index_mut_back1 i18
        let paSrc1 := index_mut_back 0#u32
        ntt.SymCryptMlKemMontgomeryReduceAndAddPolyElementAccumulatorToPolyElement_loop
          paSrc1 peDst1 i19
    else
      do
      massert (c2 < 1381#u32)
      let i13 ← c2 >>> 16#i32
      let c3 ← c2 + ntt.Q &&& i13
      let i14 ← Scalar.cast .I32 ntt.Q
      let i15 ← -. i14
      let i16 ← Scalar.cast .U32 i15
      if c3 >= i16
      then
        do
        let i17 ← c3 >>> 16#i32
        let c4 ← c3 + ntt.Q &&& i17
        massert (c4 < ntt.Q)
        let (_, index_mut_back1) ← Array.index_mut_usize peDst i
        let i18 ← Scalar.cast .U16 c4
        let i19 ← i + 1#usize
        let peDst1 := index_mut_back1 i18
        let paSrc1 := index_mut_back 0#u32
        ntt.SymCryptMlKemMontgomeryReduceAndAddPolyElementAccumulatorToPolyElement_loop
          paSrc1 peDst1 i19
      else
        do
        massert (c3 < ntt.Q)
        let i17 ← c3 >>> 16#i32
        let c4 ← c3 + ntt.Q &&& i17
        massert (c4 < ntt.Q)
        let (_, index_mut_back1) ← Array.index_mut_usize peDst i
        let i18 ← Scalar.cast .U16 c4
        let i19 ← i + 1#usize
        let peDst1 := index_mut_back1 i18
        let paSrc1 := index_mut_back 0#u32
        ntt.SymCryptMlKemMontgomeryReduceAndAddPolyElementAccumulatorToPolyElement_loop
          paSrc1 peDst1 i19
  else Result.ok (paSrc, peDst)

/- [symcrust::ntt::SymCryptMlKemMontgomeryReduceAndAddPolyElementAccumulatorToPolyElement]:
   Source: 'src/ntt.rs', lines 469:0-502:1 -/
def ntt.SymCryptMlKemMontgomeryReduceAndAddPolyElementAccumulatorToPolyElement
  (paSrc : Array U32 256#usize) (peDst : Array U16 256#usize) :
  Result ((Array U32 256#usize) × (Array U16 256#usize))
  :=
  ntt.SymCryptMlKemMontgomeryReduceAndAddPolyElementAccumulatorToPolyElement_loop
    paSrc peDst 0#usize

/- [symcrust::ntt::SymCryptMlKemPolyElementMulR]: loop 0:
   Source: 'src/ntt.rs', lines 44:8-513:5 -/
divergent def ntt.SymCryptMlKemPolyElementMulR_loop
  (peSrc : Array U16 256#usize) (peDst : Array U16 256#usize) (i : Usize) :
  Result (Array U16 256#usize)
  :=
  if i < ntt.MLWE_POLYNOMIAL_COEFFICIENTS
  then
    do
    let i1 ← Array.index_usize peSrc i
    let i2 ← core.convert.IntoFrom.into core.convert.FromU32U16 i1
    let i3 ← ntt.SymCryptMlKemMontMul i2 ntt.Rsqr ntt.RsqrTimesNegQInvModR
    let (_, index_mut_back) ← Array.index_mut_usize peDst i
    let i4 ← Scalar.cast .U16 i3
    let i5 ← i + 1#usize
    let peDst1 := index_mut_back i4
    ntt.SymCryptMlKemPolyElementMulR_loop peSrc peDst1 i5
  else Result.ok peDst

/- [symcrust::ntt::SymCryptMlKemPolyElementMulR]:
   Source: 'src/ntt.rs', lines 504:0-514:1 -/
def ntt.SymCryptMlKemPolyElementMulR
  (peSrc : Array U16 256#usize) (peDst : Array U16 256#usize) :
  Result (Array U16 256#usize)
  :=
  ntt.SymCryptMlKemPolyElementMulR_loop peSrc peDst 0#usize

/- [symcrust::ntt::SymCryptMlKemPolyElementAdd]: loop 0:
   Source: 'src/ntt.rs', lines 44:8-525:5 -/
divergent def ntt.SymCryptMlKemPolyElementAdd_loop
  (peSrc1 : Array U16 256#usize) (peSrc2 : Array U16 256#usize)
  (peDst : Array U16 256#usize) (i : Usize) :
  Result (Array U16 256#usize)
  :=
  if i < ntt.MLWE_POLYNOMIAL_COEFFICIENTS
  then
    do
    let i1 ← Array.index_usize peSrc1 i
    let i2 ← core.convert.IntoFrom.into core.convert.FromU32U16 i1
    let i3 ← Array.index_usize peSrc2 i
    let i4 ← core.convert.IntoFrom.into core.convert.FromU32U16 i3
    let i5 ← ntt.SymCryptMlKemModAdd i2 i4
    let (_, index_mut_back) ← Array.index_mut_usize peDst i
    let i6 ← Scalar.cast .U16 i5
    let i7 ← i + 1#usize
    let peDst1 := index_mut_back i6
    ntt.SymCryptMlKemPolyElementAdd_loop peSrc1 peSrc2 peDst1 i7
  else Result.ok peDst

/- [symcrust::ntt::SymCryptMlKemPolyElementAdd]:
   Source: 'src/ntt.rs', lines 516:0-526:1 -/
def ntt.SymCryptMlKemPolyElementAdd
  (peSrc1 : Array U16 256#usize) (peSrc2 : Array U16 256#usize)
  (peDst : Array U16 256#usize) :
  Result (Array U16 256#usize)
  :=
  ntt.SymCryptMlKemPolyElementAdd_loop peSrc1 peSrc2 peDst 0#usize

/- [symcrust::ntt::SymCryptMlKemPolyElementSub]: loop 0:
   Source: 'src/ntt.rs', lines 44:8-536:5 -/
divergent def ntt.SymCryptMlKemPolyElementSub_loop
  (peSrc1 : Array U16 256#usize) (peSrc2 : Array U16 256#usize)
  (peDst : Array U16 256#usize) (i : Usize) :
  Result (Array U16 256#usize)
  :=
  if i < ntt.MLWE_POLYNOMIAL_COEFFICIENTS
  then
    do
    let i1 ← Array.index_usize peSrc1 i
    let i2 ← core.convert.IntoFrom.into core.convert.FromU32U16 i1
    let i3 ← Array.index_usize peSrc2 i
    let i4 ← core.convert.IntoFrom.into core.convert.FromU32U16 i3
    let i5 ← ntt.SymCryptMlKemModSub i2 i4
    let (_, index_mut_back) ← Array.index_mut_usize peDst i
    let i6 ← Scalar.cast .U16 i5
    let i7 ← i + 1#usize
    let peDst1 := index_mut_back i6
    ntt.SymCryptMlKemPolyElementSub_loop peSrc1 peSrc2 peDst1 i7
  else Result.ok peDst

/- [symcrust::ntt::SymCryptMlKemPolyElementSub]:
   Source: 'src/ntt.rs', lines 528:0-537:1 -/
def ntt.SymCryptMlKemPolyElementSub
  (peSrc1 : Array U16 256#usize) (peSrc2 : Array U16 256#usize)
  (peDst : Array U16 256#usize) :
  Result (Array U16 256#usize)
  :=
  ntt.SymCryptMlKemPolyElementSub_loop peSrc1 peSrc2 peDst 0#usize

/- [symcrust::ntt::SymCryptMlKemPolyElementNTT]:
   Source: 'src/ntt.rs', lines 539:0-549:1 -/
def ntt.SymCryptMlKemPolyElementNTT
  (peSrc : Array U16 256#usize) : Result (Array U16 256#usize) :=
  do
  let peSrc1 ← ntt.SymCryptMlKemPolyElementNTTLayer peSrc 1#usize 128#usize
  let peSrc2 ← ntt.SymCryptMlKemPolyElementNTTLayer peSrc1 2#usize 64#usize
  let peSrc3 ← ntt.SymCryptMlKemPolyElementNTTLayer peSrc2 4#usize 32#usize
  let peSrc4 ← ntt.SymCryptMlKemPolyElementNTTLayer peSrc3 8#usize 16#usize
  let peSrc5 ← ntt.SymCryptMlKemPolyElementNTTLayer peSrc4 16#usize 8#usize
  let peSrc6 ← ntt.SymCryptMlKemPolyElementNTTLayer peSrc5 32#usize 4#usize
  ntt.SymCryptMlKemPolyElementNTTLayer peSrc6 64#usize 2#usize

/- [symcrust::ntt::INTTFixupTimesRsqr]
   Source: 'src/ntt.rs', lines 554:0-554:37 -/
def ntt.INTTFixupTimesRsqr_body : Result U32 := Result.ok 1441#u32
def ntt.INTTFixupTimesRsqr : U32 := eval_global ntt.INTTFixupTimesRsqr_body

/- [symcrust::ntt::INTTFixupTimesRsqrTimesNegQInvModR]
   Source: 'src/ntt.rs', lines 555:0-555:54 -/
def ntt.INTTFixupTimesRsqrTimesNegQInvModR_body : Result U32 :=
  Result.ok 10079#u32
def ntt.INTTFixupTimesRsqrTimesNegQInvModR : U32 :=
  eval_global ntt.INTTFixupTimesRsqrTimesNegQInvModR_body

/- [symcrust::ntt::SymCryptMlKemPolyElementINTTAndMulR]: loop 0:
   Source: 'src/ntt.rs', lines 44:8-572:5 -/
divergent def ntt.SymCryptMlKemPolyElementINTTAndMulR_loop
  (peSrc : Array U16 256#usize) (i : Usize) : Result (Array U16 256#usize) :=
  if i < ntt.MLWE_POLYNOMIAL_COEFFICIENTS
  then
    do
    let i1 ← Array.index_usize peSrc i
    let i2 ← core.convert.IntoFrom.into core.convert.FromU32U16 i1
    let i3 ←
      ntt.SymCryptMlKemMontMul i2 ntt.INTTFixupTimesRsqr
        ntt.INTTFixupTimesRsqrTimesNegQInvModR
    let (_, index_mut_back) ← Array.index_mut_usize peSrc i
    let i4 ← Scalar.cast .U16 i3
    let i5 ← i + 1#usize
    let peSrc1 := index_mut_back i4
    ntt.SymCryptMlKemPolyElementINTTAndMulR_loop peSrc1 i5
  else Result.ok peSrc

/- [symcrust::ntt::SymCryptMlKemPolyElementINTTAndMulR]:
   Source: 'src/ntt.rs', lines 557:0-573:1 -/
def ntt.SymCryptMlKemPolyElementINTTAndMulR
  (peSrc : Array U16 256#usize) : Result (Array U16 256#usize) :=
  do
  let peSrc1 ← ntt.SymCryptMlKemPolyElementINTTLayer peSrc 127#usize 2#usize
  let peSrc2 ← ntt.SymCryptMlKemPolyElementINTTLayer peSrc1 63#usize 4#usize
  let peSrc3 ← ntt.SymCryptMlKemPolyElementINTTLayer peSrc2 31#usize 8#usize
  let peSrc4 ← ntt.SymCryptMlKemPolyElementINTTLayer peSrc3 15#usize 16#usize
  let peSrc5 ← ntt.SymCryptMlKemPolyElementINTTLayer peSrc4 7#usize 32#usize
  let peSrc6 ← ntt.SymCryptMlKemPolyElementINTTLayer peSrc5 3#usize 64#usize
  let peSrc7 ← ntt.SymCryptMlKemPolyElementINTTLayer peSrc6 1#usize 128#usize
  ntt.SymCryptMlKemPolyElementINTTAndMulR_loop peSrc7 0#usize

/- [symcrust::ntt::COMPRESS_MULCONSTANT]
   Source: 'src/ntt.rs', lines 581:0-581:43 -/
def ntt.COMPRESS_MULCONSTANT_body : Result U32 := Result.ok 10321339#u32
def ntt.COMPRESS_MULCONSTANT : U32 := eval_global ntt.COMPRESS_MULCONSTANT_body

/- [symcrust::ntt::COMPRESS_SHIFTCONSTANT]
   Source: 'src/ntt.rs', lines 582:0-582:39 -/
def ntt.COMPRESS_SHIFTCONSTANT_body : Result U32 := Result.ok 35#u32
def ntt.COMPRESS_SHIFTCONSTANT : U32 :=
  eval_global ntt.COMPRESS_SHIFTCONSTANT_body

/- [symcrust::ntt::min]:
   Source: 'src/ntt.rs', lines 586:0-586:60 -/
def ntt.min (x : U32) (y : U32) : Result U32 :=
  if x <= y
  then Result.ok x
  else Result.ok y

/- [symcrust::ntt::SymCryptMlKemPolyElementCompressAndEncode::inner_loop]: loop 0:
   Source: 'src/ntt.rs', lines 634:12-651:16 -/
divergent def ntt.SymCryptMlKemPolyElementCompressAndEncode.inner_loop_loop
  (pbDst : Slice U8) (cbDstWritten : Usize) (accumulator : U32)
  (nBitsInAccumulator : U32) (nBitsInCoefficient : U32) (coefficient : U32) :
  Result ((Slice U8) × Usize × U32 × U32 × U32 × U32)
  :=
  do
  let i ← 32#u32 - nBitsInAccumulator
  let nBitsToEncode ← ntt.min nBitsInCoefficient i
  let i1 ← 1#u32 <<< nBitsToEncode
  let i2 ← i1 - 1#u32
  let coefficient1 ← coefficient >>> nBitsToEncode
  let nBitsInCoefficient1 ← nBitsInCoefficient - nBitsToEncode
  let i3 ← coefficient &&& i2 <<< nBitsInAccumulator
  let nBitsInAccumulator1 ← nBitsInAccumulator + nBitsToEncode
  if nBitsInAccumulator1 = 32#u32
  then
    do
    let i4 ← cbDstWritten + 4#usize
    let (s, index_mut_back) ←
      core.slice.index.Slice.index_mut
        (core.slice.index.SliceIndexRangeUsizeSliceTInst U8) pbDst
        { start := cbDstWritten, end_ := i4 }
    let a := core.num.U32.to_le_bytes (accumulator ||| i3)
    let s1 ← Array.to_slice a
    let s2 ← core.slice.Slice.copy_from_slice core.marker.CopyU8 s s1
    let cbDstWritten1 ← cbDstWritten + 4#usize
    if nBitsInCoefficient1 > 0#u32
    then
      let pbDst1 := index_mut_back s2
      ntt.SymCryptMlKemPolyElementCompressAndEncode.inner_loop_loop pbDst1
        cbDstWritten1 0#u32 0#u32 nBitsInCoefficient1 coefficient1
    else
      let pbDst1 := index_mut_back s2
      Result.ok (pbDst1, cbDstWritten1, 0#u32, 0#u32, nBitsInCoefficient1,
        coefficient1)
  else
    if nBitsInCoefficient1 > 0#u32
    then
      ntt.SymCryptMlKemPolyElementCompressAndEncode.inner_loop_loop pbDst
        cbDstWritten (accumulator ||| i3) nBitsInAccumulator1
        nBitsInCoefficient1 coefficient1
    else
      Result.ok (pbDst, cbDstWritten, accumulator ||| i3, nBitsInAccumulator1,
        nBitsInCoefficient1, coefficient1)

/- [symcrust::ntt::SymCryptMlKemPolyElementCompressAndEncode::inner_loop]:
   Source: 'src/ntt.rs', lines 631:8-652:9 -/
@[reducible]
def ntt.SymCryptMlKemPolyElementCompressAndEncode.inner_loop
  (pbDst : Slice U8) (cbDstWritten : Usize) (accumulator : U32)
  (nBitsInAccumulator : U32) (nBitsInCoefficient : U32) (coefficient : U32) :
  Result ((Slice U8) × Usize × U32 × U32 × U32 × U32)
  :=
  ntt.SymCryptMlKemPolyElementCompressAndEncode.inner_loop_loop pbDst
    cbDstWritten accumulator nBitsInAccumulator nBitsInCoefficient coefficient

/- [symcrust::ntt::SymCryptMlKemPolyElementCompressAndEncode]: loop 0:
   Source: 'src/ntt.rs', lines 44:8-654:5 -/
divergent def ntt.SymCryptMlKemPolyElementCompressAndEncode_loop
  (peSrc : Array U16 256#usize) (nBitsPerCoefficient : U32) (pbDst : Slice U8)
  (cbDstWritten : Usize) (accumulator : U32) (nBitsInAccumulator : U32)
  (i : Usize) :
  Result (Slice U8)
  :=
  if i < ntt.MLWE_POLYNOMIAL_COEFFICIENTS
  then
    do
    let i1 ← Array.index_usize peSrc i
    let coefficient ← core.convert.IntoFrom.into core.convert.FromU32U16 i1
    massert (coefficient < ntt.Q)
    if nBitsPerCoefficient < 12#u32
    then
      do
      let i2 ← Scalar.cast .U64 coefficient
      let i3 ← Scalar.cast .U64 ntt.COMPRESS_MULCONSTANT
      let multiplication ← i2 * i3
      let i4 ← nBitsPerCoefficient + 1#u32
      let i5 ← ntt.COMPRESS_SHIFTCONSTANT - i4
      let i6 ← multiplication >>> i5
      let coefficient1 ← Scalar.cast .U32 i6
      let coefficient2 ← coefficient1 + 1#u32
      let coefficient3 ← coefficient2 >>> 1#i32
      let i7 ← 1#u32 <<< nBitsPerCoefficient
      massert (coefficient3 <= i7)
      let i8 ← 1#u32 <<< nBitsPerCoefficient
      let i9 ← i8 - 1#u32
      let i10 ← 1#u32 <<< nBitsPerCoefficient
      massert (coefficient3 &&& i9 < i10)
      let (pbDst1, cbDstWritten1, accumulator1, nBitsInAccumulator1, _, _) ←
        ntt.SymCryptMlKemPolyElementCompressAndEncode.inner_loop pbDst
          cbDstWritten accumulator nBitsInAccumulator nBitsPerCoefficient
          (coefficient3 &&& i9)
      let i11 ← i + 1#usize
      ntt.SymCryptMlKemPolyElementCompressAndEncode_loop peSrc
        nBitsPerCoefficient pbDst1 cbDstWritten1 accumulator1
        nBitsInAccumulator1 i11
    else
      do
      let (pbDst1, cbDstWritten1, accumulator1, nBitsInAccumulator1, _, _) ←
        ntt.SymCryptMlKemPolyElementCompressAndEncode.inner_loop pbDst
          cbDstWritten accumulator nBitsInAccumulator nBitsPerCoefficient
          coefficient
      let i2 ← i + 1#usize
      ntt.SymCryptMlKemPolyElementCompressAndEncode_loop peSrc
        nBitsPerCoefficient pbDst1 cbDstWritten1 accumulator1
        nBitsInAccumulator1 i2
  else
    do
    massert (nBitsInAccumulator = 0#u32)
    let i1 ← Scalar.cast .U32 ntt.MLWE_POLYNOMIAL_COEFFICIENTS
    let i2 ← i1 / 8#u32
    let i3 ← nBitsPerCoefficient * i2
    let i4 ← Scalar.cast .Usize i3
    massert (cbDstWritten = i4)
    Result.ok pbDst

/- [symcrust::ntt::SymCryptMlKemPolyElementCompressAndEncode]:
   Source: 'src/ntt.rs', lines 588:0-658:1 -/
def ntt.SymCryptMlKemPolyElementCompressAndEncode
  (peSrc : Array U16 256#usize) (nBitsPerCoefficient : U32) (pbDst : Slice U8)
  :
  Result (Slice U8)
  :=
  do
  massert (nBitsPerCoefficient > 0#u32)
  massert (nBitsPerCoefficient <= 12#u32)
  ntt.SymCryptMlKemPolyElementCompressAndEncode_loop peSrc nBitsPerCoefficient
    pbDst 0#usize 0#u32 0#u32 0#usize

/- [symcrust::ntt::MLKEM_ERROR]
   Source: 'src/ntt.rs', lines 660:0-660:43 -/
inductive ntt.MLKEM_ERROR where
| NO_ERROR : ntt.MLKEM_ERROR
| INVALID_BLOB : ntt.MLKEM_ERROR

/- [symcrust::ntt::slice_to_sub_array]:
   Source: 'src/ntt.rs', lines 665:0-667:1 -/
axiom ntt.slice_to_sub_array
  (N : Usize) : Slice U8 → Usize → Result (Array U8 N)

/- [symcrust::ntt::SymCryptMlKemPolyElementDecodeAndDecompress::inner_loop]: loop 0:
   Source: 'src/ntt.rs', lines 696:12-718:9 -/
divergent def ntt.SymCryptMlKemPolyElementDecodeAndDecompress.inner_loop_loop
  (pbSrc : Slice U8) (nBitsPerCoefficient : U32) (cbSrcRead : Usize)
  (accumulator : U32) (nBitsInAccumulator : U32) (coefficient : U32)
  (nBitsInCoefficient : U32) :
  Result (Usize × U32 × U32 × U32 × U32)
  :=
  if nBitsInAccumulator = 0#u32
  then
    do
    let a ← ntt.slice_to_sub_array 4#usize pbSrc cbSrcRead
    let accumulator1 := core.num.U32.from_le_bytes a
    let cbSrcRead1 ← cbSrcRead + 4#usize
    let i ← nBitsPerCoefficient - nBitsInCoefficient
    let nBitsToDecode ← ntt.min i 32#u32
    massert (nBitsToDecode <= 32#u32)
    let i1 ← 1#u32 <<< nBitsToDecode
    let i2 ← i1 - 1#u32
    let accumulator2 ← accumulator1 >>> nBitsToDecode
    let nBitsInAccumulator1 ← 32#u32 - nBitsToDecode
    let i3 ← accumulator1 &&& i2 <<< nBitsInCoefficient
    let nBitsInCoefficient1 ← nBitsInCoefficient + nBitsToDecode
    if nBitsPerCoefficient > nBitsInCoefficient1
    then
      ntt.SymCryptMlKemPolyElementDecodeAndDecompress.inner_loop_loop pbSrc
        nBitsPerCoefficient cbSrcRead1 accumulator2 nBitsInAccumulator1
        (coefficient ||| i3) nBitsInCoefficient1
    else
      Result.ok (cbSrcRead1, accumulator2, nBitsInAccumulator1, coefficient |||
        i3, nBitsInCoefficient1)
  else
    do
    let i ← nBitsPerCoefficient - nBitsInCoefficient
    let nBitsToDecode ← ntt.min i nBitsInAccumulator
    massert (nBitsToDecode <= nBitsInAccumulator)
    let i1 ← 1#u32 <<< nBitsToDecode
    let i2 ← i1 - 1#u32
    let accumulator1 ← accumulator >>> nBitsToDecode
    let nBitsInAccumulator1 ← nBitsInAccumulator - nBitsToDecode
    let i3 ← accumulator &&& i2 <<< nBitsInCoefficient
    let nBitsInCoefficient1 ← nBitsInCoefficient + nBitsToDecode
    if nBitsPerCoefficient > nBitsInCoefficient1
    then
      ntt.SymCryptMlKemPolyElementDecodeAndDecompress.inner_loop_loop pbSrc
        nBitsPerCoefficient cbSrcRead accumulator1 nBitsInAccumulator1
        (coefficient ||| i3) nBitsInCoefficient1
    else
      Result.ok (cbSrcRead, accumulator1, nBitsInAccumulator1, coefficient |||
        i3, nBitsInCoefficient1)

/- [symcrust::ntt::SymCryptMlKemPolyElementDecodeAndDecompress::inner_loop]:
   Source: 'src/ntt.rs', lines 692:8-718:9 -/
@[reducible]
def ntt.SymCryptMlKemPolyElementDecodeAndDecompress.inner_loop
  (pbSrc : Slice U8) (nBitsPerCoefficient : U32) (cbSrcRead : Usize)
  (accumulator : U32) (nBitsInAccumulator : U32) (coefficient : U32)
  (nBitsInCoefficient : U32) :
  Result (Usize × U32 × U32 × U32 × U32)
  :=
  ntt.SymCryptMlKemPolyElementDecodeAndDecompress.inner_loop_loop pbSrc
    nBitsPerCoefficient cbSrcRead accumulator nBitsInAccumulator coefficient
    nBitsInCoefficient

/- [symcrust::ntt::SymCryptMlKemPolyElementDecodeAndDecompress]: loop 0:
   Source: 'src/ntt.rs', lines 44:8-757:1 -/
divergent def ntt.SymCryptMlKemPolyElementDecodeAndDecompress_loop
  (pbSrc : Slice U8) (nBitsPerCoefficient : U32) (peDst : Array U16 256#usize)
  (cbSrcRead : Usize) (accumulator : U32) (nBitsInAccumulator : U32)
  (i : Usize) :
  Result (ntt.MLKEM_ERROR × (Array U16 256#usize))
  :=
  if i < ntt.MLWE_POLYNOMIAL_COEFFICIENTS
  then
    do
    let (cbSrcRead1, accumulator1, nBitsInAccumulator1, coefficient,
      nBitsInCoefficient) ←
      ntt.SymCryptMlKemPolyElementDecodeAndDecompress.inner_loop pbSrc
        nBitsPerCoefficient cbSrcRead accumulator nBitsInAccumulator 0#u32
        0#u32
    massert (nBitsInCoefficient = nBitsPerCoefficient)
    if nBitsPerCoefficient < 12#u32
    then
      do
      let coefficient1 ← coefficient * ntt.Q
      let i1 ← nBitsPerCoefficient - 1#u32
      let coefficient2 ← coefficient1 >>> i1
      let coefficient3 ← coefficient2 + 1#u32
      let coefficient4 ← coefficient3 >>> 1#i32
      let coefficient5 ← ntt.SymCryptMlKemModSub coefficient4 ntt.Q
      massert (coefficient5 < ntt.Q)
      let (_, index_mut_back) ← Array.index_mut_usize peDst i
      let i2 ← Scalar.cast .U16 coefficient5
      let i3 ← i + 1#usize
      let peDst1 := index_mut_back i2
      ntt.SymCryptMlKemPolyElementDecodeAndDecompress_loop pbSrc
        nBitsPerCoefficient peDst1 cbSrcRead1 accumulator1 nBitsInAccumulator1
        i3
    else
      if coefficient > ntt.Q
      then Result.ok (ntt.MLKEM_ERROR.INVALID_BLOB, peDst)
      else
        do
        let (_, index_mut_back) ← Array.index_mut_usize peDst i
        let i1 ← Scalar.cast .U16 coefficient
        let i2 ← i + 1#usize
        let peDst1 := index_mut_back i1
        ntt.SymCryptMlKemPolyElementDecodeAndDecompress_loop pbSrc
          nBitsPerCoefficient peDst1 cbSrcRead1 accumulator1
          nBitsInAccumulator1 i2
  else
    do
    massert (nBitsInAccumulator = 0#u32)
    let i1 ← Scalar.cast .U32 ntt.MLWE_POLYNOMIAL_COEFFICIENTS
    let i2 ← i1 / 8#u32
    let i3 ← nBitsPerCoefficient * i2
    let i4 ← Scalar.cast .Usize i3
    massert (cbSrcRead = i4)
    Result.ok (ntt.MLKEM_ERROR.NO_ERROR, peDst)

/- [symcrust::ntt::SymCryptMlKemPolyElementDecodeAndDecompress]:
   Source: 'src/ntt.rs', lines 670:0-757:1 -/
def ntt.SymCryptMlKemPolyElementDecodeAndDecompress
  (pbSrc : Slice U8) (nBitsPerCoefficient : U32) (peDst : Array U16 256#usize)
  :
  Result (ntt.MLKEM_ERROR × (Array U16 256#usize))
  :=
  do
  massert (nBitsPerCoefficient > 0#u32)
  massert (nBitsPerCoefficient <= 12#u32)
  ntt.SymCryptMlKemPolyElementDecodeAndDecompress_loop pbSrc
    nBitsPerCoefficient peDst 0#usize 0#u32 0#u32 0#usize

/- [symcrust::ntt::SymCryptShake128Extract]:
   Source: 'src/ntt.rs', lines 760:0-767:1 -/
axiom ntt.SymCryptShake128Extract
  :
  Array U8 0#usize → Slice U8 → Bool → Result ((Array U8 0#usize) ×
    (Slice U8))

/- [symcrust::ntt::SymCryptMlKemPolyElementSampleNTTFromShake128]: loop 0:
   Source: 'src/ntt.rs', lines 777:4-800:5 -/
divergent def ntt.SymCryptMlKemPolyElementSampleNTTFromShake128_loop
  (pState : Array U8 0#usize) (peDst : Array U16 256#usize) (i : Usize)
  (shakeOutputBuf : Array U8 24#usize) (currBufIndex : Usize) :
  Result ((Array U8 0#usize) × (Array U16 256#usize))
  :=
  if i < ntt.MLWE_POLYNOMIAL_COEFFICIENTS
  then
    do
    let s ← Array.to_slice shakeOutputBuf
    let i1 := Slice.len s
    massert (currBufIndex <= i1)
    let s1 ← Array.to_slice shakeOutputBuf
    let i2 := Slice.len s1
    if currBufIndex = i2
    then
      do
      let (s2, to_slice_mut_back) ← Array.to_slice_mut shakeOutputBuf
      let (pState1, s3) ← ntt.SymCryptShake128Extract pState s2 false
      let shakeOutputBuf1 := to_slice_mut_back s3
      let s4 ← Array.to_slice shakeOutputBuf1
      let a ← ntt.slice_to_sub_array 2#usize s4 0#usize
      let i3 := core.num.U16.from_le_bytes a
      let s5 ← Array.to_slice shakeOutputBuf1
      let i4 ← 0#usize + 1#usize
      let a1 ← ntt.slice_to_sub_array 2#usize s5 i4
      let i5 := core.num.U16.from_le_bytes a1
      let sample1 ← i5 >>> 4#i32
      let currBufIndex1 ← 0#usize + 3#usize
      let (_, index_mut_back) ← Array.index_mut_usize peDst i
      let i6 ← Scalar.cast .U32 (i3 &&& 4095#u16)
      let i7 ← Scalar.cast_bool .Usize (i6 < ntt.Q)
      let i8 ← i + i7
      if i8 < ntt.MLWE_POLYNOMIAL_COEFFICIENTS
      then
        do
        let peDst1 := index_mut_back (i3 &&& 4095#u16)
        let (_, index_mut_back1) ← Array.index_mut_usize peDst1 i8
        let i9 ← Scalar.cast .U32 sample1
        let i10 ← Scalar.cast_bool .Usize (i9 < ntt.Q)
        let i11 ← i8 + i10
        let peDst2 := index_mut_back1 sample1
        ntt.SymCryptMlKemPolyElementSampleNTTFromShake128_loop pState1 peDst2
          i11 shakeOutputBuf1 currBufIndex1
      else
        let peDst1 := index_mut_back (i3 &&& 4095#u16)
        ntt.SymCryptMlKemPolyElementSampleNTTFromShake128_loop pState1 peDst1
          i8 shakeOutputBuf1 currBufIndex1
    else
      do
      let s2 ← Array.to_slice shakeOutputBuf
      let a ← ntt.slice_to_sub_array 2#usize s2 currBufIndex
      let i3 := core.num.U16.from_le_bytes a
      let s3 ← Array.to_slice shakeOutputBuf
      let i4 ← currBufIndex + 1#usize
      let a1 ← ntt.slice_to_sub_array 2#usize s3 i4
      let i5 := core.num.U16.from_le_bytes a1
      let sample1 ← i5 >>> 4#i32
      let currBufIndex1 ← currBufIndex + 3#usize
      let (_, index_mut_back) ← Array.index_mut_usize peDst i
      let i6 ← Scalar.cast .U32 (i3 &&& 4095#u16)
      let i7 ← Scalar.cast_bool .Usize (i6 < ntt.Q)
      let i8 ← i + i7
      if i8 < ntt.MLWE_POLYNOMIAL_COEFFICIENTS
      then
        do
        let peDst1 := index_mut_back (i3 &&& 4095#u16)
        let (_, index_mut_back1) ← Array.index_mut_usize peDst1 i8
        let i9 ← Scalar.cast .U32 sample1
        let i10 ← Scalar.cast_bool .Usize (i9 < ntt.Q)
        let i11 ← i8 + i10
        let peDst2 := index_mut_back1 sample1
        ntt.SymCryptMlKemPolyElementSampleNTTFromShake128_loop pState peDst2
          i11 shakeOutputBuf currBufIndex1
      else
        let peDst1 := index_mut_back (i3 &&& 4095#u16)
        ntt.SymCryptMlKemPolyElementSampleNTTFromShake128_loop pState peDst1 i8
          shakeOutputBuf currBufIndex1
  else Result.ok (pState, peDst)

/- [symcrust::ntt::SymCryptMlKemPolyElementSampleNTTFromShake128]:
   Source: 'src/ntt.rs', lines 769:0-801:1 -/
def ntt.SymCryptMlKemPolyElementSampleNTTFromShake128
  (pState : Array U8 0#usize) (peDst : Array U16 256#usize) :
  Result ((Array U8 0#usize) × (Array U16 256#usize))
  :=
  do
  let shakeOutputBuf := Array.repeat 24#usize 0#u8
  let s ← Array.to_slice shakeOutputBuf
  let currBufIndex := Slice.len s
  ntt.SymCryptMlKemPolyElementSampleNTTFromShake128_loop pState peDst 0#usize
    shakeOutputBuf currBufIndex

/- [symcrust::ntt::SymCryptMlKemPolyElementSampleCBDFromBytes::else_inner_loop]: loop 0:
   Source: 'src/ntt.rs', lines 44:8-870:24 -/
divergent def
  ntt.SymCryptMlKemPolyElementSampleCBDFromBytes.else_inner_loop_loop
  (peDst : Array U16 256#usize) (i : Usize) (sampleBits : U32) (j : Usize) :
  Result ((Array U16 256#usize) × U32)
  :=
  if j < 8#usize
  then
    do
    let sampleBits1 ← sampleBits >>> 4#i32
    let i1 ← sampleBits &&& 15#u32 >>> 2#i32
    let coefficient ← sampleBits &&& 15#u32 &&& 3#u32 - i1
    let i2 ← Scalar.cast .U32 (-2)#i32
    if coefficient >= i2
    then
      do
      let i3 ← coefficient >>> 16#i32
      let coefficient1 ← coefficient + ntt.Q &&& i3
      massert (coefficient1 < ntt.Q)
      let i4 ← i + j
      let (_, index_mut_back) ← Array.index_mut_usize peDst i4
      let i5 ← Scalar.cast .U16 coefficient1
      let j1 ← j + 1#usize
      let peDst1 := index_mut_back i5
      ntt.SymCryptMlKemPolyElementSampleCBDFromBytes.else_inner_loop_loop
        peDst1 i sampleBits1 j1
    else
      do
      massert (coefficient <= 2#u32)
      let i3 ← coefficient >>> 16#i32
      let coefficient1 ← coefficient + ntt.Q &&& i3
      massert (coefficient1 < ntt.Q)
      let i4 ← i + j
      let (_, index_mut_back) ← Array.index_mut_usize peDst i4
      let i5 ← Scalar.cast .U16 coefficient1
      let j1 ← j + 1#usize
      let peDst1 := index_mut_back i5
      ntt.SymCryptMlKemPolyElementSampleCBDFromBytes.else_inner_loop_loop
        peDst1 i sampleBits1 j1
  else Result.ok (peDst, sampleBits)

/- [symcrust::ntt::SymCryptMlKemPolyElementSampleCBDFromBytes::else_inner_loop]:
   Source: 'src/ntt.rs', lines 856:12-871:13 -/
def ntt.SymCryptMlKemPolyElementSampleCBDFromBytes.else_inner_loop
  (peDst : Array U16 256#usize) (i : Usize) (sampleBits : U32) :
  Result ((Array U16 256#usize) × U32)
  :=
  ntt.SymCryptMlKemPolyElementSampleCBDFromBytes.else_inner_loop_loop peDst i
    sampleBits 0#usize

/- [symcrust::ntt::SymCryptMlKemPolyElementSampleCBDFromBytes::then_inner_loop]: loop 0:
   Source: 'src/ntt.rs', lines 44:8-839:24 -/
divergent def
  ntt.SymCryptMlKemPolyElementSampleCBDFromBytes.then_inner_loop_loop
  (peDst : Array U16 256#usize) (i : Usize) (sampleBits : U32) (j : Usize) :
  Result ((Array U16 256#usize) × U32)
  :=
  if j < 4#usize
  then
    do
    let sampleBits1 ← sampleBits >>> 6#i32
    let i1 ← sampleBits &&& 63#u32 >>> 3#i32
    let coefficient ← sampleBits &&& 63#u32 &&& 3#u32 - i1
    let i2 ← Scalar.cast .U32 (-3)#i32
    if coefficient >= i2
    then
      do
      let i3 ← coefficient >>> 16#i32
      let coefficient1 ← coefficient + ntt.Q &&& i3
      massert (coefficient1 < ntt.Q)
      let i4 ← i + j
      let (_, index_mut_back) ← Array.index_mut_usize peDst i4
      let i5 ← Scalar.cast .U16 coefficient1
      let j1 ← j + 1#usize
      let peDst1 := index_mut_back i5
      ntt.SymCryptMlKemPolyElementSampleCBDFromBytes.then_inner_loop_loop
        peDst1 i sampleBits1 j1
    else
      do
      massert (coefficient <= 3#u32)
      let i3 ← coefficient >>> 16#i32
      let coefficient1 ← coefficient + ntt.Q &&& i3
      massert (coefficient1 < ntt.Q)
      let i4 ← i + j
      let (_, index_mut_back) ← Array.index_mut_usize peDst i4
      let i5 ← Scalar.cast .U16 coefficient1
      let j1 ← j + 1#usize
      let peDst1 := index_mut_back i5
      ntt.SymCryptMlKemPolyElementSampleCBDFromBytes.then_inner_loop_loop
        peDst1 i sampleBits1 j1
  else Result.ok (peDst, sampleBits)

/- [symcrust::ntt::SymCryptMlKemPolyElementSampleCBDFromBytes::then_inner_loop]:
   Source: 'src/ntt.rs', lines 825:12-840:13 -/
def ntt.SymCryptMlKemPolyElementSampleCBDFromBytes.then_inner_loop
  (peDst : Array U16 256#usize) (i : Usize) (sampleBits : U32) :
  Result ((Array U16 256#usize) × U32)
  :=
  ntt.SymCryptMlKemPolyElementSampleCBDFromBytes.then_inner_loop_loop peDst i
    sampleBits 0#usize

/- [symcrust::ntt::SymCryptMlKemPolyElementSampleCBDFromBytes]: loop 0:
   Source: 'src/ntt.rs', lines 44:8-842:9 -/
divergent def ntt.SymCryptMlKemPolyElementSampleCBDFromBytes_loop0
  (pbSrc : Slice U8) (peDst : Array U16 256#usize) (src_i : Usize) (i : Usize)
  :
  Result (Array U16 256#usize)
  :=
  if i < ntt.MLWE_POLYNOMIAL_COEFFICIENTS
  then
    do
    let a ← ntt.slice_to_sub_array 4#usize pbSrc src_i
    let sampleBits := core.num.U32.from_le_bytes a
    let src_i1 ← src_i + 3#usize
    let i1 ← sampleBits >>> 1#i32
    let i2 ← sampleBits &&& 2396745#u32 + i1 &&& 2396745#u32
    let i3 ← sampleBits >>> 2#i32
    let sampleBits1 ← i2 + i3 &&& 2396745#u32
    let (peDst1, _) ←
      ntt.SymCryptMlKemPolyElementSampleCBDFromBytes.then_inner_loop peDst i
        sampleBits1
    let i4 ← i + 1#usize
    ntt.SymCryptMlKemPolyElementSampleCBDFromBytes_loop0 pbSrc peDst1 src_i1 i4
  else Result.ok peDst

/- [symcrust::ntt::SymCryptMlKemPolyElementSampleCBDFromBytes]: loop 1:
   Source: 'src/ntt.rs', lines 44:8-873:9 -/
divergent def ntt.SymCryptMlKemPolyElementSampleCBDFromBytes_loop1
  (pbSrc : Slice U8) (peDst : Array U16 256#usize) (src_i : Usize) (i : Usize)
  :
  Result (Array U16 256#usize)
  :=
  if i < ntt.MLWE_POLYNOMIAL_COEFFICIENTS
  then
    do
    let a ← ntt.slice_to_sub_array 4#usize pbSrc src_i
    let sampleBits := core.num.U32.from_le_bytes a
    let src_i1 ← src_i + 4#usize
    let i1 ← sampleBits >>> 1#i32
    let sampleBits1 ← sampleBits &&& 1431655765#u32 + i1 &&& 1431655765#u32
    let (peDst1, _) ←
      ntt.SymCryptMlKemPolyElementSampleCBDFromBytes.else_inner_loop peDst i
        sampleBits1
    let i2 ← i + 1#usize
    ntt.SymCryptMlKemPolyElementSampleCBDFromBytes_loop1 pbSrc peDst1 src_i1 i2
  else Result.ok peDst

/- [symcrust::ntt::SymCryptMlKemPolyElementSampleCBDFromBytes]: loop 2:
   Source: 'src/ntt.rs', lines 44:8-842:9 -/
divergent def ntt.SymCryptMlKemPolyElementSampleCBDFromBytes_loop2
  (pbSrc : Slice U8) (peDst : Array U16 256#usize) (src_i : Usize) (i : Usize)
  :
  Result (Array U16 256#usize)
  :=
  if i < ntt.MLWE_POLYNOMIAL_COEFFICIENTS
  then
    do
    let a ← ntt.slice_to_sub_array 4#usize pbSrc src_i
    let sampleBits := core.num.U32.from_le_bytes a
    let src_i1 ← src_i + 3#usize
    let i1 ← sampleBits >>> 1#i32
    let i2 ← sampleBits &&& 2396745#u32 + i1 &&& 2396745#u32
    let i3 ← sampleBits >>> 2#i32
    let sampleBits1 ← i2 + i3 &&& 2396745#u32
    let (peDst1, _) ←
      ntt.SymCryptMlKemPolyElementSampleCBDFromBytes.then_inner_loop peDst i
        sampleBits1
    let i4 ← i + 1#usize
    ntt.SymCryptMlKemPolyElementSampleCBDFromBytes_loop2 pbSrc peDst1 src_i1 i4
  else Result.ok peDst

/- [symcrust::ntt::SymCryptMlKemPolyElementSampleCBDFromBytes]: loop 3:
   Source: 'src/ntt.rs', lines 44:8-873:9 -/
divergent def ntt.SymCryptMlKemPolyElementSampleCBDFromBytes_loop3
  (pbSrc : Slice U8) (peDst : Array U16 256#usize) (src_i : Usize) (i : Usize)
  :
  Result (Array U16 256#usize)
  :=
  if i < ntt.MLWE_POLYNOMIAL_COEFFICIENTS
  then
    do
    let a ← ntt.slice_to_sub_array 4#usize pbSrc src_i
    let sampleBits := core.num.U32.from_le_bytes a
    let src_i1 ← src_i + 4#usize
    let i1 ← sampleBits >>> 1#i32
    let sampleBits1 ← sampleBits &&& 1431655765#u32 + i1 &&& 1431655765#u32
    let (peDst1, _) ←
      ntt.SymCryptMlKemPolyElementSampleCBDFromBytes.else_inner_loop peDst i
        sampleBits1
    let i2 ← i + 1#usize
    ntt.SymCryptMlKemPolyElementSampleCBDFromBytes_loop3 pbSrc peDst1 src_i1 i2
  else Result.ok peDst

/- [symcrust::ntt::SymCryptMlKemPolyElementSampleCBDFromBytes]:
   Source: 'src/ntt.rs', lines 803:0-875:1 -/
def ntt.SymCryptMlKemPolyElementSampleCBDFromBytes
  (pbSrc : Slice U8) (eta : U32) (peDst : Array U16 256#usize) :
  Result (Array U16 256#usize)
  :=
  if eta = 2#u32
  then
    if eta = 3#u32
    then
      ntt.SymCryptMlKemPolyElementSampleCBDFromBytes_loop0 pbSrc peDst 0#usize
        0#usize
    else
      ntt.SymCryptMlKemPolyElementSampleCBDFromBytes_loop1 pbSrc peDst 0#usize
        0#usize
  else
    do
    massert (eta = 3#u32)
    if eta = 3#u32
    then
      ntt.SymCryptMlKemPolyElementSampleCBDFromBytes_loop2 pbSrc peDst 0#usize
        0#usize
    else
      ntt.SymCryptMlKemPolyElementSampleCBDFromBytes_loop3 pbSrc peDst 0#usize
        0#usize

/- [symcrust::ntt::{symcrust::ntt::MATRIX<'a>}::swap]:
   Source: 'src/ntt.rs', lines 880:4-888:5 -/
axiom ntt.MATRIX.swap
  :
  ntt.MATRIX → Usize → Usize → Result (ntt.MATRIX × (ntt.MATRIX →
    ntt.MATRIX))

/- [symcrust::ntt::SymCryptMlKemMatrixTranspose::inner_loop]: loop 0:
   Source: 'src/ntt.rs', lines 44:8-907:13 -/
divergent def ntt.SymCryptMlKemMatrixTranspose.inner_loop_loop
  (i : Usize) (a : Array (Array U16 256#usize) 16#usize) (nRows : Usize)
  (i1 : Usize) (j : Usize) :
  Result (ntt.MATRIX × (ntt.MATRIX → Array (Array U16 256#usize) 16#usize))
  :=
  if j < nRows
  then
    do
    let i2 ← i1 * nRows
    let i3 ← i2 + j
    let i4 ← j * nRows
    let i5 ← i4 + i1
    let (m, swap_back) ←
      ntt.MATRIX.swap { nRows := i, apPolyElements := a } i3 i5
    let j1 ← j + 1#usize
    let (m1, back) ←
      ntt.SymCryptMlKemMatrixTranspose.inner_loop_loop m.nRows m.apPolyElements
        nRows i1 j1
    let back1 :=
      fun ret =>
        let a1 := back ret
        (swap_back { m with apPolyElements := a1 }).apPolyElements
    Result.ok (m1, back1)
  else
    let back := fun ret => ret.apPolyElements
    Result.ok ({ nRows := i, apPolyElements := a }, back)

/- [symcrust::ntt::SymCryptMlKemMatrixTranspose::inner_loop]:
   Source: 'src/ntt.rs', lines 903:8-909:9 -/
def ntt.SymCryptMlKemMatrixTranspose.inner_loop
  (pmSrc : ntt.MATRIX) (nRows : Usize) (i : Usize) :
  Result (ntt.MATRIX × (ntt.MATRIX → ntt.MATRIX))
  :=
  do
  let j ← i + 1#usize
  let (m, back) ←
    ntt.SymCryptMlKemMatrixTranspose.inner_loop_loop pmSrc.nRows
      pmSrc.apPolyElements nRows i j
  let back1 := fun ret => let a := back ret
                          { pmSrc with apPolyElements := a }
  Result.ok (m, back1)

/- [symcrust::ntt::SymCryptMlKemMatrixTranspose]: loop 0:
   Source: 'src/ntt.rs', lines 44:8-911:5 -/
divergent def ntt.SymCryptMlKemMatrixTranspose_loop
  (nRows : Usize) (a : Array (Array U16 256#usize) 16#usize) (nRows1 : Usize)
  (i : Usize) :
  Result (ntt.MATRIX × (ntt.MATRIX → Array (Array U16 256#usize) 16#usize))
  :=
  if i < nRows1
  then
    do
    let (m, inner_loop_back) ←
      ntt.SymCryptMlKemMatrixTranspose.inner_loop
        { nRows, apPolyElements := a } nRows1 i
    let i1 ← i + 1#usize
    let (m1, back) ←
      ntt.SymCryptMlKemMatrixTranspose_loop m.nRows m.apPolyElements nRows1 i1
    let back1 :=
      fun ret =>
        let a1 := back ret
        (inner_loop_back { m with apPolyElements := a1 }).apPolyElements
    Result.ok (m1, back1)
  else
    let back := fun ret => ret.apPolyElements
    Result.ok ({ nRows, apPolyElements := a }, back)

/- [symcrust::ntt::SymCryptMlKemMatrixTranspose]:
   Source: 'src/ntt.rs', lines 891:0-913:1 -/
def ntt.SymCryptMlKemMatrixTranspose
  (pmSrc : ntt.MATRIX) : Result (ntt.MATRIX × (ntt.MATRIX → ntt.MATRIX)) :=
  do
  massert (pmSrc.nRows > 0#usize)
  massert (pmSrc.nRows <= ntt.MATRIX_MAX_NROWS)
  let (m, back) ←
    ntt.SymCryptMlKemMatrixTranspose_loop pmSrc.nRows pmSrc.apPolyElements
      pmSrc.nRows 0#usize
  let back1 := fun ret => let a := back ret
                          { pmSrc with apPolyElements := a }
  Result.ok (m, back1)

/- [symcrust::ntt::SymCryptMlKemPolyElementMulAndAccumulate_aux]:
   Source: 'src/ntt.rs', lines 918:0-928:1 -/
axiom ntt.SymCryptMlKemPolyElementMulAndAccumulate_aux
  :
  ntt.MATRIX → Usize → Usize → Usize → Array U16 256#usize → Array
    U32 256#usize → Result (ntt.MATRIX × (ntt.MATRIX → ntt.MATRIX) ×
    (Array U32 256#usize))

/- [symcrust::ntt::SymCryptMlKemMatrixVectorMontMulAndAdd::inner_loop]: loop 0:
   Source: 'src/ntt.rs', lines 44:8-963:13 -/
divergent def ntt.SymCryptMlKemMatrixVectorMontMulAndAdd.inner_loop_loop
  (i : Usize) (a : Array (Array U16 256#usize) 16#usize)
  (pvSrc2 : Slice (Array U16 256#usize)) (paTmp : Array U32 256#usize)
  (nRows : Usize) (i1 : Usize) (j : Usize) :
  Result (ntt.MATRIX × (ntt.MATRIX → Array (Array U16 256#usize) 16#usize)
    × (Array U32 256#usize))
  :=
  if j < nRows
  then
    do
    let a1 ← Slice.index_usize pvSrc2 i1
    let (m, SymCryptMlKemPolyElementMulAndAccumulate_aux_back, paTmp1) ←
      ntt.SymCryptMlKemPolyElementMulAndAccumulate_aux
        { nRows := i, apPolyElements := a } nRows i1 j a1 paTmp
    let j1 ← j + 1#usize
    let (m1, back'a, paTmp2) ←
      ntt.SymCryptMlKemMatrixVectorMontMulAndAdd.inner_loop_loop m.nRows
        m.apPolyElements pvSrc2 paTmp1 nRows i1 j1
    let back'a1 :=
      fun ret =>
        let a2 := back'a ret
        (SymCryptMlKemPolyElementMulAndAccumulate_aux_back
           { m with apPolyElements := a2 }).apPolyElements
    Result.ok (m1, back'a1, paTmp2)
  else
    let back'a := fun ret => ret.apPolyElements
    Result.ok ({ nRows := i, apPolyElements := a }, back'a, paTmp)

/- [symcrust::ntt::SymCryptMlKemMatrixVectorMontMulAndAdd::inner_loop]:
   Source: 'src/ntt.rs', lines 954:8-965:9 -/
def ntt.SymCryptMlKemMatrixVectorMontMulAndAdd.inner_loop
  (pmSrc1 : ntt.MATRIX) (pvSrc2 : Slice (Array U16 256#usize))
  (paTmp : Array U32 256#usize) (nRows : Usize) (i : Usize) :
  Result (ntt.MATRIX × (ntt.MATRIX → ntt.MATRIX) × (Array U32 256#usize))
  :=
  do
  let (m, back'a, paTmp1) ←
    ntt.SymCryptMlKemMatrixVectorMontMulAndAdd.inner_loop_loop pmSrc1.nRows
      pmSrc1.apPolyElements pvSrc2 paTmp nRows i 0#usize
  let back'a1 :=
    fun ret => let a := back'a ret
               { pmSrc1 with apPolyElements := a }
  Result.ok (m, back'a1, paTmp1)

/- [symcrust::ntt::SymCryptMlKemMatrixVectorMontMulAndAdd]: loop 0:
   Source: 'src/ntt.rs', lines 44:8-970:5 -/
divergent def ntt.SymCryptMlKemMatrixVectorMontMulAndAdd_loop
  (nRows : Usize) (a : Array (Array U16 256#usize) 16#usize)
  (pvSrc2 : Slice (Array U16 256#usize)) (pvDst : Slice (Array U16 256#usize))
  (paTmp : Array U32 256#usize) (nRows1 : Usize) (i : Usize) :
  Result (ntt.MATRIX × (ntt.MATRIX → Array (Array U16 256#usize) 16#usize)
    × (Slice (Array U16 256#usize)) × (Array U32 256#usize))
  :=
  if i < nRows1
  then
    do
    let (m, inner_loop_back, paTmp1) ←
      ntt.SymCryptMlKemMatrixVectorMontMulAndAdd.inner_loop
        { nRows, apPolyElements := a } pvSrc2 paTmp nRows1 i
    let (a1, index_mut_back) ← Slice.index_mut_usize pvDst i
    let (paTmp2, a2) ←
      ntt.SymCryptMlKemMontgomeryReduceAndAddPolyElementAccumulatorToPolyElement
        paTmp1 a1
    let i1 ← i + 1#usize
    let pvDst1 := index_mut_back a2
    let (m1, back'a, pvDst2, paTmp3) ←
      ntt.SymCryptMlKemMatrixVectorMontMulAndAdd_loop m.nRows m.apPolyElements
        pvSrc2 pvDst1 paTmp2 nRows1 i1
    let back'a1 :=
      fun ret =>
        let a3 := back'a ret
        (inner_loop_back { m with apPolyElements := a3 }).apPolyElements
    Result.ok (m1, back'a1, pvDst2, paTmp3)
  else
    let back'a := fun ret => ret.apPolyElements
    Result.ok ({ nRows, apPolyElements := a }, back'a, pvDst, paTmp)

/- [symcrust::ntt::SymCryptMlKemMatrixVectorMontMulAndAdd]:
   Source: 'src/ntt.rs', lines 932:0-972:1 -/
def ntt.SymCryptMlKemMatrixVectorMontMulAndAdd
  (pmSrc1 : ntt.MATRIX) (pvSrc2 : Slice (Array U16 256#usize))
  (pvDst : Slice (Array U16 256#usize)) (paTmp : Array U32 256#usize) :
  Result (ntt.MATRIX × (ntt.MATRIX → ntt.MATRIX) × (Slice (Array U16
    256#usize)) × (Array U32 256#usize))
  :=
  do
  massert (pmSrc1.nRows > 0#usize)
  massert (pmSrc1.nRows <= ntt.MATRIX_MAX_NROWS)
  let i := Slice.len pvSrc2
  massert (i = pmSrc1.nRows)
  let i1 := Slice.len pvDst
  massert (i1 = pmSrc1.nRows)
  let (m, back'a, pvDst1, paTmp1) ←
    ntt.SymCryptMlKemMatrixVectorMontMulAndAdd_loop pmSrc1.nRows
      pmSrc1.apPolyElements pvSrc2 pvDst paTmp pmSrc1.nRows 0#usize
  let back'a1 :=
    fun ret => let a := back'a ret
               { pmSrc1 with apPolyElements := a }
  Result.ok (m, back'a1, pvDst1, paTmp1)

/- [symcrust::ntt::SymCryptMlKemVectorMontDotProduct]: loop 0:
   Source: 'src/ntt.rs', lines 44:8-996:5 -/
divergent def ntt.SymCryptMlKemVectorMontDotProduct_loop
  (pvSrc1 : Slice (Array U16 256#usize)) (pvSrc2 : Slice (Array U16 256#usize))
  (peDst : Array U16 256#usize) (paTmp : Array U32 256#usize) (nRows : Usize)
  (i : Usize) :
  Result (Array U32 256#usize)
  :=
  if i < nRows
  then
    do
    let a ← Slice.index_usize pvSrc1 i
    let a1 ← Slice.index_usize pvSrc2 i
    let paTmp1 ← ntt.SymCryptMlKemPolyElementMulAndAccumulate a a1 paTmp
    let i1 ← i + 1#usize
    ntt.SymCryptMlKemVectorMontDotProduct_loop pvSrc1 pvSrc2 peDst paTmp1 nRows
      i1
  else
    do
    let (paTmp1, _) ←
      ntt.SymCryptMlKemMontgomeryReduceAndAddPolyElementAccumulatorToPolyElement
        paTmp peDst
    Result.ok paTmp1

/- [symcrust::ntt::SymCryptMlKemVectorMontDotProduct]:
   Source: 'src/ntt.rs', lines 975:0-1000:1 -/
def ntt.SymCryptMlKemVectorMontDotProduct
  (pvSrc1 : Slice (Array U16 256#usize)) (pvSrc2 : Slice (Array U16 256#usize))
  (peDst : Array U16 256#usize) (paTmp : Array U32 256#usize) :
  Result ((Slice (Array U16 256#usize)) × (Slice (Array U16 256#usize)) ×
    (Array U16 256#usize) × (Array U32 256#usize))
  :=
  do
  let nRows := Slice.len pvSrc1
  massert (nRows > 0#usize)
  massert (nRows <= ntt.MATRIX_MAX_NROWS)
  let i := Slice.len pvSrc2
  massert (i = nRows)
  let paTmp1 ←
    ntt.SymCryptMlKemVectorMontDotProduct_loop pvSrc1 pvSrc2 peDst paTmp nRows
      0#usize
  Result.ok (pvSrc1, pvSrc2, peDst, paTmp1)

/- [symcrust::ntt::SymCryptMlKemVectorSetZero]:
   Source: 'src/ntt.rs', lines 1002:0-1014:1 -/
def ntt.SymCryptMlKemVectorSetZero
  (pvSrc : Slice (Array U16 256#usize)) :
  Result (Slice (Array U16 256#usize))
  :=
  do
  let nRows := Slice.len pvSrc
  massert (nRows > 0#usize)
  massert (nRows <= ntt.MATRIX_MAX_NROWS)
  Result.ok pvSrc

/- [symcrust::ntt::SymCryptMlKemVectorMulR]: loop 0:
   Source: 'src/ntt.rs', lines 44:8-1030:5 -/
divergent def ntt.SymCryptMlKemVectorMulR_loop
  (pvSrc : Slice (Array U16 256#usize)) (pvDst : Slice (Array U16 256#usize))
  (nRows : Usize) (i : Usize) :
  Result (Slice (Array U16 256#usize))
  :=
  if i < nRows
  then
    do
    let a ← Slice.index_usize pvSrc i
    let (a1, index_mut_back) ← Slice.index_mut_usize pvDst i
    let a2 ← ntt.SymCryptMlKemPolyElementMulR a a1
    let i1 ← i + 1#usize
    let pvDst1 := index_mut_back a2
    ntt.SymCryptMlKemVectorMulR_loop pvSrc pvDst1 nRows i1
  else Result.ok pvDst

/- [symcrust::ntt::SymCryptMlKemVectorMulR]:
   Source: 'src/ntt.rs', lines 1016:0-1031:1 -/
def ntt.SymCryptMlKemVectorMulR
  (pvSrc : Slice (Array U16 256#usize)) (pvDst : Slice (Array U16 256#usize)) :
  Result (Slice (Array U16 256#usize))
  :=
  do
  let nRows := Slice.len pvSrc
  massert (nRows > 0#usize)
  massert (nRows <= ntt.MATRIX_MAX_NROWS)
  let i := Slice.len pvDst
  massert (i = nRows)
  ntt.SymCryptMlKemVectorMulR_loop pvSrc pvDst nRows 0#usize

/- [symcrust::ntt::SymCryptMlKemVectorAdd]: loop 0:
   Source: 'src/ntt.rs', lines 44:8-1049:5 -/
divergent def ntt.SymCryptMlKemVectorAdd_loop
  (pvSrc1 : Slice (Array U16 256#usize)) (pvSrc2 : Slice (Array U16 256#usize))
  (pvDst : Slice (Array U16 256#usize)) (nRows : Usize) (i : Usize) :
  Result (Slice (Array U16 256#usize))
  :=
  if i < nRows
  then
    do
    let a ← Slice.index_usize pvSrc1 i
    let a1 ← Slice.index_usize pvSrc2 i
    let (a2, index_mut_back) ← Slice.index_mut_usize pvDst i
    let a3 ← ntt.SymCryptMlKemPolyElementAdd a a1 a2
    let i1 ← i + 1#usize
    let pvDst1 := index_mut_back a3
    ntt.SymCryptMlKemVectorAdd_loop pvSrc1 pvSrc2 pvDst1 nRows i1
  else Result.ok pvDst

/- [symcrust::ntt::SymCryptMlKemVectorAdd]:
   Source: 'src/ntt.rs', lines 1033:0-1050:1 -/
def ntt.SymCryptMlKemVectorAdd
  (pvSrc1 : Slice (Array U16 256#usize)) (pvSrc2 : Slice (Array U16 256#usize))
  (pvDst : Slice (Array U16 256#usize)) :
  Result (Slice (Array U16 256#usize))
  :=
  do
  let nRows := Slice.len pvSrc1
  massert (nRows > 0#usize)
  massert (nRows <= ntt.MATRIX_MAX_NROWS)
  let i := Slice.len pvSrc2
  massert (i = nRows)
  let i1 := Slice.len pvDst
  massert (i1 = nRows)
  ntt.SymCryptMlKemVectorAdd_loop pvSrc1 pvSrc2 pvDst nRows 0#usize

/- [symcrust::ntt::SymCryptMlKemVectorSub]: loop 0:
   Source: 'src/ntt.rs', lines 44:8-1068:5 -/
divergent def ntt.SymCryptMlKemVectorSub_loop
  (pvSrc1 : Slice (Array U16 256#usize)) (pvSrc2 : Slice (Array U16 256#usize))
  (pvDst : Slice (Array U16 256#usize)) (nRows : Usize) (i : Usize) :
  Result (Slice (Array U16 256#usize))
  :=
  if i < nRows
  then
    do
    let a ← Slice.index_usize pvSrc1 i
    let a1 ← Slice.index_usize pvSrc2 i
    let (a2, index_mut_back) ← Slice.index_mut_usize pvDst i
    let a3 ← ntt.SymCryptMlKemPolyElementSub a a1 a2
    let i1 ← i + 1#usize
    let pvDst1 := index_mut_back a3
    ntt.SymCryptMlKemVectorSub_loop pvSrc1 pvSrc2 pvDst1 nRows i1
  else Result.ok pvDst

/- [symcrust::ntt::SymCryptMlKemVectorSub]:
   Source: 'src/ntt.rs', lines 1052:0-1069:1 -/
def ntt.SymCryptMlKemVectorSub
  (pvSrc1 : Slice (Array U16 256#usize)) (pvSrc2 : Slice (Array U16 256#usize))
  (pvDst : Slice (Array U16 256#usize)) :
  Result (Slice (Array U16 256#usize))
  :=
  do
  let nRows := Slice.len pvSrc1
  massert (nRows > 0#usize)
  massert (nRows <= ntt.MATRIX_MAX_NROWS)
  let i := Slice.len pvSrc2
  massert (i = nRows)
  let i1 := Slice.len pvDst
  massert (i1 = nRows)
  ntt.SymCryptMlKemVectorSub_loop pvSrc1 pvSrc2 pvDst nRows 0#usize

/- [symcrust::ntt::SymCryptMlKemVectorNTT]: loop 0:
   Source: 'src/ntt.rs', lines 44:8-1083:5 -/
divergent def ntt.SymCryptMlKemVectorNTT_loop
  (pvSrc : Slice (Array U16 256#usize)) (nRows : Usize) (i : Usize) :
  Result (Slice (Array U16 256#usize))
  :=
  if i < nRows
  then
    do
    let (a, index_mut_back) ← Slice.index_mut_usize pvSrc i
    let a1 ← ntt.SymCryptMlKemPolyElementNTT a
    let i1 ← i + 1#usize
    let pvSrc1 := index_mut_back a1
    ntt.SymCryptMlKemVectorNTT_loop pvSrc1 nRows i1
  else Result.ok pvSrc

/- [symcrust::ntt::SymCryptMlKemVectorNTT]:
   Source: 'src/ntt.rs', lines 1071:0-1084:1 -/
def ntt.SymCryptMlKemVectorNTT
  (pvSrc : Slice (Array U16 256#usize)) :
  Result (Slice (Array U16 256#usize))
  :=
  do
  let nRows := Slice.len pvSrc
  massert (nRows > 0#usize)
  massert (nRows <= ntt.MATRIX_MAX_NROWS)
  ntt.SymCryptMlKemVectorNTT_loop pvSrc nRows 0#usize

/- [symcrust::ntt::SymCryptMlKemVectorINTTAndMulR]: loop 0:
   Source: 'src/ntt.rs', lines 44:8-1098:5 -/
divergent def ntt.SymCryptMlKemVectorINTTAndMulR_loop
  (pvSrc : Slice (Array U16 256#usize)) (nRows : Usize) (i : Usize) :
  Result (Slice (Array U16 256#usize))
  :=
  if i < nRows
  then
    do
    let (a, index_mut_back) ← Slice.index_mut_usize pvSrc i
    let a1 ← ntt.SymCryptMlKemPolyElementINTTAndMulR a
    let i1 ← i + 1#usize
    let pvSrc1 := index_mut_back a1
    ntt.SymCryptMlKemVectorINTTAndMulR_loop pvSrc1 nRows i1
  else Result.ok pvSrc

/- [symcrust::ntt::SymCryptMlKemVectorINTTAndMulR]:
   Source: 'src/ntt.rs', lines 1086:0-1099:1 -/
def ntt.SymCryptMlKemVectorINTTAndMulR
  (pvSrc : Slice (Array U16 256#usize)) :
  Result (Slice (Array U16 256#usize))
  :=
  do
  let nRows := Slice.len pvSrc
  massert (nRows > 0#usize)
  massert (nRows <= ntt.MATRIX_MAX_NROWS)
  ntt.SymCryptMlKemVectorINTTAndMulR_loop pvSrc nRows 0#usize

/- [core::ops::range::RangeFrom]
   Source: '/rustc/library/core/src/ops/range.rs', lines 189:0-189:25
   Name pattern: core::ops::range::RangeFrom -/
structure core.ops.range.RangeFrom (Idx : Type) where
  start : Idx

/- Trait implementation: [core::slice::index::private_slice_index::{core::slice::index::private_slice_index::Sealed for core::ops::range::RangeFrom<usize>}#3]
   Source: '/rustc/library/core/src/slice/index.rs', lines 162:4-162:41
   Name pattern: core::slice::index::private_slice_index::Sealed<core::ops::range::RangeFrom<usize>> -/
@[reducible]
def core.slice.index.private_slice_index.SealedcoreopsrangeRangeFromUsize :
  core.slice.index.private_slice_index.Sealed (core.ops.range.RangeFrom Usize)
  := {
}

/- [core::slice::index::{core::slice::index::SliceIndex<@Slice<T>> for core::ops::range::RangeFrom<usize>}#7::get]:
   Source: '/rustc/library/core/src/slice/index.rs', lines 565:4-565:45
   Name pattern: core::slice::index::{core::slice::index::SliceIndex<core::ops::range::RangeFrom<usize>, [@T]>}::get -/
axiom core.slice.index.SliceIndexcoreopsrangeRangeFromUsizeSlice.get
  {T : Type} :
  core.ops.range.RangeFrom Usize → Slice T → Result (Option (Slice T))

/- [core::slice::index::{core::slice::index::SliceIndex<@Slice<T>> for core::ops::range::RangeFrom<usize>}#7::get_mut]:
   Source: '/rustc/library/core/src/slice/index.rs', lines 570:4-570:57
   Name pattern: core::slice::index::{core::slice::index::SliceIndex<core::ops::range::RangeFrom<usize>, [@T]>}::get_mut -/
axiom core.slice.index.SliceIndexcoreopsrangeRangeFromUsizeSlice.get_mut
  {T : Type} :
  core.ops.range.RangeFrom Usize → Slice T → Result ((Option (Slice T)) ×
    (Option (Slice T) → Slice T))

/- [core::slice::index::{core::slice::index::SliceIndex<@Slice<T>> for core::ops::range::RangeFrom<usize>}#7::get_unchecked]:
   Source: '/rustc/library/core/src/slice/index.rs', lines 575:4-575:66
   Name pattern: core::slice::index::{core::slice::index::SliceIndex<core::ops::range::RangeFrom<usize>, [@T]>}::get_unchecked -/
axiom core.slice.index.SliceIndexcoreopsrangeRangeFromUsizeSlice.get_unchecked
  {T : Type} :
  core.ops.range.RangeFrom Usize → ConstRawPtr (Slice T) → Result
    (ConstRawPtr (Slice T))

/- [core::slice::index::{core::slice::index::SliceIndex<@Slice<T>> for core::ops::range::RangeFrom<usize>}#7::get_unchecked_mut]:
   Source: '/rustc/library/core/src/slice/index.rs', lines 581:4-581:66
   Name pattern: core::slice::index::{core::slice::index::SliceIndex<core::ops::range::RangeFrom<usize>, [@T]>}::get_unchecked_mut -/
axiom
  core.slice.index.SliceIndexcoreopsrangeRangeFromUsizeSlice.get_unchecked_mut
  {T : Type} :
  core.ops.range.RangeFrom Usize → MutRawPtr (Slice T) → Result (MutRawPtr
    (Slice T))

/- [core::slice::index::{core::slice::index::SliceIndex<@Slice<T>> for core::ops::range::RangeFrom<usize>}#7::index]:
   Source: '/rustc/library/core/src/slice/index.rs', lines 587:4-587:39
   Name pattern: core::slice::index::{core::slice::index::SliceIndex<core::ops::range::RangeFrom<usize>, [@T]>}::index -/
axiom core.slice.index.SliceIndexcoreopsrangeRangeFromUsizeSlice.index
  {T : Type} : core.ops.range.RangeFrom Usize → Slice T → Result (Slice T)

/- [core::slice::index::{core::slice::index::SliceIndex<@Slice<T>> for core::ops::range::RangeFrom<usize>}#7::index_mut]:
   Source: '/rustc/library/core/src/slice/index.rs', lines 596:4-596:51
   Name pattern: core::slice::index::{core::slice::index::SliceIndex<core::ops::range::RangeFrom<usize>, [@T]>}::index_mut -/
axiom core.slice.index.SliceIndexcoreopsrangeRangeFromUsizeSlice.index_mut
  {T : Type} :
  core.ops.range.RangeFrom Usize → Slice T → Result ((Slice T) × (Slice T
    → Slice T))

/- Trait implementation: [core::slice::index::{core::slice::index::SliceIndex<@Slice<T>> for core::ops::range::RangeFrom<usize>}#7]
   Source: '/rustc/library/core/src/slice/index.rs', lines 561:0-561:56
   Name pattern: core::slice::index::SliceIndex<core::ops::range::RangeFrom<usize>, [@Self]> -/
@[reducible]
def core.slice.index.SliceIndexcoreopsrangeRangeFromUsizeSlice (T : Type) :
  core.slice.index.SliceIndex (core.ops.range.RangeFrom Usize) (Slice T) := {
  Output := Slice T
  sealedInst :=
    core.slice.index.private_slice_index.SealedcoreopsrangeRangeFromUsize
  get := core.slice.index.SliceIndexcoreopsrangeRangeFromUsizeSlice.get
  get_mut := core.slice.index.SliceIndexcoreopsrangeRangeFromUsizeSlice.get_mut
  get_unchecked :=
    core.slice.index.SliceIndexcoreopsrangeRangeFromUsizeSlice.get_unchecked
  get_unchecked_mut :=
    core.slice.index.SliceIndexcoreopsrangeRangeFromUsizeSlice.get_unchecked_mut
  index := core.slice.index.SliceIndexcoreopsrangeRangeFromUsizeSlice.index
  index_mut :=
    core.slice.index.SliceIndexcoreopsrangeRangeFromUsizeSlice.index_mut
}

/- [symcrust::ntt::SymCryptMlKemVectorCompressAndEncode]: loop 0:
   Source: 'src/ntt.rs', lines 44:8-1122:5 -/
divergent def ntt.SymCryptMlKemVectorCompressAndEncode_loop
  (pvSrc : Slice (Array U16 256#usize)) (nBitsPerCoefficient : U32)
  (pbDst : Slice U8) (nRows : Usize) (i : Usize) :
  Result (Slice U8)
  :=
  if i < nRows
  then
    do
    let i1 ← Scalar.cast .Usize nBitsPerCoefficient
    let i2 ← i * i1
    let i3 ← ntt.MLWE_POLYNOMIAL_COEFFICIENTS / 8#usize
    let pbDst_index ← i2 * i3
    let a ← Slice.index_usize pvSrc i
    let (s, index_mut_back) ←
      core.slice.index.Slice.index_mut
        (core.slice.index.SliceIndexcoreopsrangeRangeFromUsizeSlice U8) pbDst
        { start := pbDst_index }
    let s1 ←
      ntt.SymCryptMlKemPolyElementCompressAndEncode a nBitsPerCoefficient s
    let i4 ← i + 1#usize
    let pbDst1 := index_mut_back s1
    ntt.SymCryptMlKemVectorCompressAndEncode_loop pvSrc nBitsPerCoefficient
      pbDst1 nRows i4
  else Result.ok pbDst

/- [symcrust::ntt::SymCryptMlKemVectorCompressAndEncode]:
   Source: 'src/ntt.rs', lines 1101:0-1123:1 -/
def ntt.SymCryptMlKemVectorCompressAndEncode
  (pvSrc : Slice (Array U16 256#usize)) (nBitsPerCoefficient : U32)
  (pbDst : Slice U8) (cbDst : Usize) :
  Result (Slice U8)
  :=
  do
  let nRows := Slice.len pvSrc
  massert (nRows > 0#usize)
  massert (nRows <= ntt.MATRIX_MAX_NROWS)
  massert (nBitsPerCoefficient > 0#u32)
  massert (nBitsPerCoefficient <= 12#u32)
  let i ← Scalar.cast .U32 ntt.MLWE_POLYNOMIAL_COEFFICIENTS
  let i1 ← i / 8#u32
  let i2 ← nBitsPerCoefficient * i1
  let i3 ← Scalar.cast .Usize i2
  let i4 ← nRows * i3
  massert (cbDst = i4)
  ntt.SymCryptMlKemVectorCompressAndEncode_loop pvSrc nBitsPerCoefficient pbDst
    nRows 0#usize

/- [symcrust::ntt::SymCryptMlKemVectorDecodeAndDecompress]: loop 0:
   Source: 'src/ntt.rs', lines 44:8-1147:1 -/
divergent def ntt.SymCryptMlKemVectorDecodeAndDecompress_loop
  (pbSrc : Slice U8) (nBitsPerCoefficient : U32)
  (pvDst : Slice (Array U16 256#usize)) (nRows : Usize) (i : Usize) :
  Result (ntt.MLKEM_ERROR × (Slice (Array U16 256#usize)))
  :=
  if i < nRows
  then
    do
    let i1 ← Scalar.cast .Usize nBitsPerCoefficient
    let i2 ← i * i1
    let i3 ← ntt.MLWE_POLYNOMIAL_COEFFICIENTS / 8#usize
    let pbSrc_index ← i2 * i3
    let s ←
      core.slice.index.Slice.index
        (core.slice.index.SliceIndexcoreopsrangeRangeFromUsizeSlice U8) pbSrc
        { start := pbSrc_index }
    let (a, index_mut_back) ← Slice.index_mut_usize pvDst i
    let (scError, a1) ←
      ntt.SymCryptMlKemPolyElementDecodeAndDecompress s nBitsPerCoefficient a
    match scError with
    | ntt.MLKEM_ERROR.NO_ERROR =>
      let pvDst1 := index_mut_back a1
      Result.ok (ntt.MLKEM_ERROR.NO_ERROR, pvDst1)
    | ntt.MLKEM_ERROR.INVALID_BLOB =>
      do
      let i4 ← i + 1#usize
      let pvDst1 := index_mut_back a1
      ntt.SymCryptMlKemVectorDecodeAndDecompress_loop pbSrc nBitsPerCoefficient
        pvDst1 nRows i4
  else Result.ok (ntt.MLKEM_ERROR.NO_ERROR, pvDst)

/- [symcrust::ntt::SymCryptMlKemVectorDecodeAndDecompress]:
   Source: 'src/ntt.rs', lines 1125:0-1147:1 -/
def ntt.SymCryptMlKemVectorDecodeAndDecompress
  (pbSrc : Slice U8) (cbSrc : Usize) (nBitsPerCoefficient : U32)
  (pvDst : Slice (Array U16 256#usize)) :
  Result (ntt.MLKEM_ERROR × (Slice (Array U16 256#usize)))
  :=
  do
  let nRows := Slice.len pvDst
  massert (nRows > 0#usize)
  massert (nRows <= ntt.MATRIX_MAX_NROWS)
  massert (nBitsPerCoefficient > 0#u32)
  massert (nBitsPerCoefficient <= 12#u32)
  let i ← Scalar.cast .Usize nBitsPerCoefficient
  let i1 ← nRows * i
  let i2 ← ntt.MLWE_POLYNOMIAL_COEFFICIENTS / 8#usize
  let i3 ← i1 * i2
  massert (cbSrc = i3)
  ntt.SymCryptMlKemVectorDecodeAndDecompress_loop pbSrc nBitsPerCoefficient
    pvDst nRows 0#usize

/- [symcrust::misc::Temporaries]
   Source: 'src/misc.rs', lines 2:0-5:1 -/
structure misc.Temporaries where
  data1 : Array U8 16#usize
  data2 : Array U8 16#usize

/- [symcrust::misc::main]:
   Source: 'src/misc.rs', lines 8:0-21:1 -/
axiom misc.main : Result Unit

end symcrust
